{"meta":{"title":"Yucong's Blog","subtitle":null,"description":"No matter where we are going, it starts from where we are","author":"体力劳动者","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Make frontend development easy again","slug":"Functional-UI","date":"2017-12-25T01:29:02.000Z","updated":"2017-12-25T02:56:34.225Z","comments":true,"path":"2017/12/25/Functional-UI/","link":"","permalink":"http://yoursite.com/2017/12/25/Functional-UI/","excerpt":"","text":"前端很难吗？为什么想讲这个话题，因为咱们作为前端开发者，经常有被其他领域的工程师质疑：“你整天都在忙啥。不就是画个UI有那么难么？”当然我们可以找出很多例子来证明UI真的可以很难很高科技，比如说天猫那个魔术一般的navigation bar，但是我们加班真的在忙这些东西吗？我猜测绝大多数人跟我一样，头疼的task和bug都来自于无穷无尽的业务逻辑，表单，表格当中。所以我个人是很想赞同他们的质疑：“前端真的有那么难吗？” 很多技术都是出现的时候十分难，经过科学家和工程师们的不断努力，越来越强大，却反而越来越友好，比如说编程本身，功能已经无处不在，却早已不是那个只有尖端科学家才能学习的稀罕东西。web开发似乎是个例外，功能上的爆炸式增长的同时，javascript似乎变得越来越难以捉摸。 田园时代西方的诗歌喜欢怀念田园时代，就是那个城市高楼手机汽车要啥没啥但是因为简单美好让大家觉得是遗失的天堂。古时候的Web开发也有这么一个时代，我们连JavaScript都没有，和我们提起前端脑子里“蹭”就冒出javascript可完全不一样。但我们确实可以完全不用JavaScript进行Web开发，比如经典的structs，spring，asp.net。这里我们姑且称那时为web开发的田园时代，简单，清晰，让人觉得舒服和美好。 虽然不是百分之百的场景还原，但是让我们花一分钟感受一下依赖ROR如何开发一个最基本的Web上的用户登录。用ruby是因为不用为一大堆花括号排版ppt，请大家不要关注语言谢谢。 这是很纯粹的一个MVC pattern的server side rendering,Model和Controller都是在服务器上运行的代码，View是在server端渲染好，再以html的形式返回给浏览器呈现给用户。Model的作用 ，是用来管理数据。这个例子中，我们建了一张用户表，有name和password两个字段。当然实际项目如果这么存password后果比较严重，大家不要模仿，User Model描述了我们需要校验name存在以及一个大写的变换。 View的作用，是把model用人类可交互的方式在网页上display给用户，比如绘制了一个form，并且将model中的相应字段填进去并且指定了表单提交的地址，我们在这里省略了关于样式和页面上的细节组件。 Controller用来handler business logic。这个例子里，我们只完成了认证通过的部分：将id计入session，redirect到landing url。虽然这是很业余的一种做法，只是为了demo方便，但是实际项目中也无非是用真实的持久化登陆状态的过程替换，完整的计算出一个user info并且交给landing view来渲染。(下一页)没有JavaScript，我们完成这样一个登陆的web页面。 建表(当然production中这么建表被fire了后果自负) 123456CREATE TABLE user ( id int(11) NNOT NULL auto_increment, name varchar(255), password varchar(255), PRIMARY KEY (id)); model 1234567class User &lt; ApplicationRecord validates :name, presence: true before_create do self.name = login.capitalize if name.blank? endend view 12345&lt;%= form_tag(\"/login\", method: \"post\") do %&gt; &lt;%= text_field_tag(:name) %&gt; &lt;%= password_field_tag(:password) %&gt; &lt;%= submit_tag(\"Search\") %&gt;&lt;% end %&gt; 12&lt;h1&gt;Welcome&lt;/h1&gt;&lt;h3&gt;Hello: &lt;%= user.name %&gt;&lt;/h3&gt; controller 123456789class LoginsController &lt; ApplicationController def create if user = User.authenticate(params[:username], params[:password]) session[:current_user_id] = user.id redirect_to landing_url end endend UI和业务逻辑没有太多耦合这就是我们所描述的田园时代，简单清晰。展示层，或者我们所说的View和业务逻辑，就是那段controller代码，只是通过model的字段定义有数据接口上的约定，没有其余的耦合。Controller处理业务逻辑，操作我们的model。View用来展示model。想象我们现在不用ejs作为模板引擎了，比如说用pug，controller基本不用啥改动。同样的，现在我们把db用mongodb替代mysql（事实上，我推荐个人小项目这么干），view基本不用改。即使业务变复杂，这个原则不会改变。 换成knockout呢。。。1&lt;div data-bind=\"css: &#123; profitWarning: currentProfit() &lt; 0, majorHighlight: isSevere &#125;\"&gt; 工业文明：欢迎来到JavaScript和SPA的世界但是为什么我们现在都move到了JavaScript的世界，都采用SPA来开发？人们做生意都不想做赔本生意，这里也是，我们为了好处和解决问题而来。 首先，服务端渲染的performance很差。我们需要在服务端操作model，渲染出整个页面，然后以html的形式返回给前端，效果很差。哪怕计算的结果是刚才的login form下面只多了一行字：“对不起，您的密码有误”另外，重画整个页面除了很差的perf，对用户体验的副作用也是很大的，原来focus在密码框里的光标会lose focus，重新填写还要再点一下。就像刚才Shixin讲的，这是一个ui friction此外，没有ajax，我们无法做到异步操作。我们等待密码验证的时候什么事都干不了。从开发者的角度，在浏览器上debug和连上服务器debug，体验不可同日而语。比如说，对于lsr，连上prod server去打断点不会是一个美好的回忆。 Server side rendering has poor performance Whole page redrawing has bad user experience Cannot do asynchronous tasks Difficult to debug on servers 代价就像现代文明会带来环境污染一样，我们付出了代价。 一个严重的问题，就是UI和业务逻辑开始深度耦合。现在我们不黑ko了，这是angular官网上的例子当然angular是一个优秀的框架，涉及到了和今天的topic无关的设计哲学，咱们这里就不讨论了。 1234567891011121314151617&lt;div id=\"ctrl-as-exmpl\" ng-controller=\"SettingsController1 as settings\"&gt; &lt;label&gt;Name: &lt;input type=\"text\" ng-model=\"settings.name\"/&gt;&lt;/label&gt; &lt;button ng-click=\"settings.greet()\"&gt;greet&lt;/button&gt;&lt;br/&gt; Contact: &lt;ul&gt; &lt;li ng-repeat=\"contact in settings.contacts\"&gt; &lt;select ng-model=\"contact.type\" aria-label=\"Contact method\" id=\"select_&#123;&#123;$index&#125;&#125;\"&gt; &lt;option&gt;phone&lt;/option&gt; &lt;option&gt;email&lt;/option&gt; &lt;/select&gt; &lt;input type=\"text\" ng-model=\"contact.value\" aria-labelledby=\"select_&#123;&#123;$index&#125;&#125;\" /&gt; &lt;button ng-click=\"settings.clearContact(contact)\"&gt;clear&lt;/button&gt; &lt;button ng-click=\"settings.removeContact(contact)\" aria-label=\"Remove\"&gt;X&lt;/button&gt; &lt;/li&gt; &lt;li&gt;&lt;button ng-click=\"settings.addContact()\"&gt;add&lt;/button&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; debug: 更难诊断这样的第一个后果，出现在deBug上。确实，用浏览器比起连上server，打断点的体验好一些。但是打几个断点？在哪打断点？传统的MVC，debug很难，但是，找到rootcause很简单。刚才的例子啊，名字变到hello之前了，那我们知道在view里出问题了。发现那么不是我们想要的，ok看下controll里findUserById的调用处打断点。现在混合之后，页面上的元素组织甚至在和model或者viewmodel里数据的拓扑结构绑定，我们无从查起。更不用说，所有data binding为基础的框架，我们更多的看到这样的error message所以，来到浏览器上，我们开始debug不难了，但是，还是得加班 扩展：难以refactor和修改设计第二个问题，就是我们的修改，变麻烦了。讲这样一个故事啊，我们的campaign creation，也就是让advertiser创建campaign流程中，需要用户设置自己campaign的budget。这个要求即使对于初学者也是小菜一碟。 我们的campaign creation分为4个大的步骤。PM想到了，他在中间步骤的时候会重新考量自己的业务，这样在最后一步，他经常发现在第一步设置的budget需要修改。当然，依然还有很多advertiser对于自己有多少钱是心中有数的，所以想在第一步设置好。所以，我们解决ui friction的办法就是，两边都放上。 对于以前的模式，这不是问题，在最后一步view里面加一个budget input，把model填进去，搞定。如果你在用什么java ant tomcat，那就敲一下f5然后出去吃夜宵。 现在的话，嗯，比方这样一个问题啊： 如果我们让这两个budget control是一个instance:因为每一步的next和back button都会validate当前step所有的form,那么实际上，第一步和第四步的都执行了自己步骤以外的validation，这导致了很多bug；如果让他们是不同的instance，需要构造两次不说，其他受budget影响的component都需要监听或者分辨来自不同budget control的事件，或者判断传入的instance是不是当前想要的。数据和validation同步也是可能导致问题的。 我们这个讨论还没结束呢，另一个crew开始找我们集成shared budget。业务上来说，几个campaign可以用同一个shared budget；工程上来说，就是我们原来写的budget的control成为了新的budget panel的子组件。在viewmodel里，hierarchy同时影响了页面上的布局和逻辑里的关系，牵一发而动全身。 另外一方面，如果将来我们有更多的选项，需要用dropdown替换radio button，显然这种UI和业务逻辑耦合的做法会带来更多的困扰 新问题：引入异步带来的坑再就是concurency。新加入的功能引来了新的问题。 我们的render和destroy方法都是同步的。因为lazy loading的需求，我们需要在render的时候再加载一个第三方库，加载成功之后会创建一系列新的实体在其子节点上。destroy的时候，需要讲他们一一销毁：这时，一个很容易出bug的问题诞生了：你怎么知道destroy的时候render及其异步操作已经全部完成。稍不小心就会让程序进入无法预测的异常状态。 改框架，render和destroy都支持promise。 好主意，加油（微笑）争取明年release（doge） 加全局flag 我们确实很多时候是怎么干的。 异步之后又fork出新的异步task怎么办 你怎么能保证线程安全？怎么能保证flag不被修改？如果之后的业务告诉你确实要修改flag怎么办？比如说，有两个同时进行的lazy loading。掀桌。 文艺复兴我们付出的这些代价，就是可以讨论的可以改进的空间。我们想变得更好。原来简单，清晰。我们要重新变简单，变清晰。 那么，当时move到JavaScript SPA的时候，不就是把server sider rendering换成client side rendering嘛，其他的逻辑组织一切都不变，完全平移到client side。或者说用javascript强行写一个ror或者asp.net搁浏览器里跑，可行吗？ 可行倒是可行，但是频繁的重画整个dom tree，依然让perf和体验不理想，可以归结为ui friction。 那为什么现在我们又能重新讨论这个话题了呢？上周关于react的分享中，我们知道了virtual dom这个概念。这个想法太赞了，我们在code里不管怎样重新render都没有关系，多了一层来帮我们计算delta来作partial rendering，即使我们让数据一圈一圈转起来，都不用担心perf 都不用担心ux了。 另一方面，现在的UI，组件话已经越来愈好，对于很多局部的小控件，其实啊，重画是完全可以接受的，并不是ui friction，比方说，你就是一个小小的date picker之类的。 好了，现在我们可以回头找一下那一些被迫放弃的田园时代的美好吧。不过千万不要忘了，异步的问题是新带来的，我们还需要解决 如何思考？既然已经打出了文艺复兴的旗号啊，接下来咱们就会在把那些以前落了灰的东西翻出来，收拾收拾里面精华的思想，然后总结一套 让我们的开发重新变简单 的思路和方法。 实际上react分享的时候，已经有这样的问题被提出来，如果我把view model中引起问题的那个数据流方向干掉，是不是就可以实现跟react类似的功能。perf问题？没关系，也有很好的开源的virtual dom技术。 why not？没错，我们今天的topic，不需要任何新的framework也好 library也好。当然，有些跟我熟一点的知道我是某些新东西的粉丝。放心，我不是来传销他们的。如果你有听过启发我讲这个topic的那些新东西，希望你能理解 原来是这个原因 我才喜欢他 如果你不知道那是啥 更好 希望你能知道 啊 原来老的代码里 还能这样想。 Business requirements -&gt; mathematic problems -&gt; code我们上班是来干嘛的？ 我们是来解决问题的 然后用解决问题的能力兑换成薪水 程序员怎么解决问题？ 我们把实际的业务抽象成数学问题 然后把解决这个数学问题的方案用代码写出来 从田园controller开始重温一下什么是controller：它是用来handle业务逻辑的，具体的，干了两件事：第一，操作model，用时髦的说法，这句话很重要：执行model的状态转移。第二，根据业务，把相应的model交给相应的view，进行渲染 我们的业务逻辑 描述model的状态转移：实际上就是根据一些条件，对model执行了一个函数，得到了一个新的model 重复一遍：执行了一个函数，得到了一个新的model：而不是执行了一条命令，修改了model。 为了让问题更简单，我们做一个尝试，让刚才说的“一些条件”全部由操作时的parameter来表示，其他因素要么放进去，要么被忽略。 我们还想要更进一步的简单和清晰。OK，model里有字段，还有描述model变换的方法。我们不要，我们只需要一个最最简单的数据结构，比如说，简单到就是一个简单的plain object。我们给它一个更准确描述这个plain object的名字： state 对于parameters 推广到普遍适用的情况，我们给他的名字叫 action，动作，来自哪里的动作？我不关心 1state_next = r(state, actions) 我们的UI再来看controller的另一个任务：把相应的model交给相应的view，进行渲染。 What is a view? To display model 也就是说，View是什么？View就是把model扔在屏幕上，使其可以和用户交互的一种映射。回忆一下高中数学，把model可能的状态看成定义域，UI所有可能的显示看成值域，这是什么？一个函数 跟之前一样的解释：model拓广到states 我们得到了 1UI = f(state) 是的 UI只听state的 你想说 我的页面，要在晚上10：00到早上8：00把页面弄成适合夜间的尿黄色。OK，请在state里描述时间。我的页面，在中国用高德map，在美国用google map。OK，请在state里描述location。 UI就干你改干的事，清清楚楚。 state怎么这么累？f说，我不知道，你问r去 这就是今天我想阐述的核心 敲黑板重点 1UI = f(r(state, action)) UI = f(r(state, action)): 欢迎来到函数的世界我们的工作 怎么描述一个时间点上静态的状态？这是state的问题 怎么描述发生的一切和其他实体，比如用户的交互？这是action 怎么让state和action相互作用，完成业务逻辑的要求？找一个合适的r。我会忍住不说我最喜欢的那个很新的r，我后面会证明，你们正在用的那些被嫌弃的老技术，也可以是很好的r 怎么在真正的页面上让state说人话？找一个合适的f，同样的，别看不起你们现在用的。 更进一步解释我给出的这个式子。 第一件事情：前面已有说明，f和r就是数学意义上真正的函数，不是我们平时干的写作function用成command或这procedure的那些假冒伪劣产品。在编程上 我们称为纯函数。第二件事情：只是再强调一遍，我不是来推销某个framework的，这种pattern，对所有的中立。第三件事情：这种pattern，实际上已经解决了开始提出的一个重要的问题：UI和business logic耦合 我们的数学基础范畴论 Category theory首先是范畴论：将这些概念形式化成一组组的“物件”及“态射” 解释了为什么pure function对干扰免疫，没有副作用 思考问题的时候，一定注意把pure function理解成pipe，而不是execute，重点！pipe！ 这就是函数式编程最基本的模型：函数就是箭头，值就是点（后面λ演算可以更丧（gan）心（de）病（piao）狂（liang）的指出值也是函数），除了两个点，这就是一个纯粹的数学模型，不会和任何其他的点或者箭头发生交互。这个箭头不会吃掉它出发的点，不会改变它到达的点，它就是像一跟管道一样。没错，一定要把函数理解成管道，不要理解成命令！我们的思维在这里转变。 λ演算 λ calculusλ-terms（解释了为什么“函数是一等公民”）形象的说，就解释了函数，不仅是箭头，也可以是点。函数本身就是一种值的类型。evaluation（解释了柯里化的数学原理，解释了FP对于异步和并行的优势，启发我们不要用传统的考虑“值”的思路（call by value）去理解而是call by name）λ表达式只允许一个参数，柯里化可多个。函数应用可以把函数整体代入，不是先要求值：这就是我们天天写的callback啊 我们的工具纯函数 pure functions 重温一下pure funciton的概念，之前react的分享里已经提到过的 两个要求： 第一：输入确定，则输出确定。第二：没有副作用，或者说，它只能干一件事请，就是输出一个值，其他什么改一个全局变量啊全都不行。 换句话说，pure function就是纯数学意义上的函数，编程上是stateless function，没有internal state。 我们建造新大厦的砖块在这个pattern中，pure function就是我们编程的砖块。为什么选择这个当砖块？因为它最简单，也最容易复用。 首先，它完全对这样一大类bug免疫，就是一堆人在改同一个可变的东西，什么out of sync或者inconsistent的问题。因为每块砖只关心自己的输入。另外因为这个特性，它一定是并行编程的很好的候选方案。第三，它完全不关注自己受谁的影响，自己会影响谁。在哪都一样，很容易的就搬来搬去。 我猜有人会用随机数生成的问题来challenge。没问题，只需要知道随机数需要seed就好了。 当然，等真的写code的时候，我们想的一定是怎么解决实际问题，而不是怎么套用design pattern，我们想的是怎么用pure function的思想提高我们思考的效率，而不是绞尽脑汁套pure function来降低我们思考的效率，be smart Javascript并不是一门非常适合函数式编程的语言 我们的动机 We want UI to be predicable We want states transforming be predicable Reusability, Flexibility and Extensibility 我们的做法Immutable不推荐的 1234567function selectionProjectionHandler(state, config, model) &#123; if (config.selectable) &#123; // ... &#125; else &#123; state.errorCode = 'error_unselectable’; &#125;&#125; 推荐的 123456789function selectionProjectionHandler(state, config, model) &#123; if (config.selectable) &#123; return /* compose new state with item selection */ &#125; // Immutable return Object.assign(&#123;&#125;, state, &#123; errorCode: 'error_unselectable’, &#125;);&#125; 其实很简单 别改 返回一个新的 当然这个例子说明了一个问题是 如果你的目标是学习函数式编程 显然JavaScript不是一个合适的选择 这里的语法看起来不太直观 甚至可以说 是一个work around： 因为那个新的对象 其实就是这个空的花括号修饰出来的 没错 这不是immutable 我们产生了修改这个空object的副作用 强调一遍 我想讲的是怎么借助这些思想让我们开发变简单 而immutablejs这个库的作用 就是强制copy on write 对于map array set这些基础的结构做了封装 recap一个pure function： 干且仅干一件事情 接受一个输入 给一个输出 Partial applying偏函数解决这样的问题：如果我们有函数是多个参数的，我们希望能固定其中某几个参数的值 123456789function log(status, context, message) &#123; // fancy logging code here&#125; function info(context, message) &#123; return log('info', context, message);&#125; function dbInfo(message) &#123; return info('db', message);&#125; Currying 柯里化下面来讲柯里化 因为λ演算表现成code 最纯净的函数定义是一个参数进去 一个参数出来 但是我们实际业务很容易描述成具有多个参数的情形 所以我们需要柯里化 只提供一个参数 其他的参数作为这个函数的“环境”来创建，来回归原始 大家回想一下自己备战高考的岁月啊 数学里函数的部分占了大头对吧 大家重温一下只有一个参数的题的难度 和有多个参数的题的难度 应该就有一个感性的认识了 现在我们做项目 不就是两步：先把实际问题数学化 再把数学解答代码化？好 想展开一个话题 随便google一篇文章都比我这讲得好 就不浪费时间了 柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。指的是将一个具有多个参数的函数，转换成能够通过一系列的函数链式调用，其中每一个函数都只有一个参数 我们还是拿log这个例子来说明 123456789101112function log(status) &#123; return function(context) &#123; return function(message) &#123; // fancy logging code here &#125;; &#125;;&#125;const info = log('info’);info('db-context')('message');const dbInfo = info('db'); // create a new function againdbInfo('something happened’);log('other level')('some context')('a message'); 这就是柯里化 其实没那么玄乎 我们把一个关注三个参数的问题 变成了三个分别只有一个参数的函数的链式调用 我们想要创建之前的info函数 就把status=info理解成创建这个新函数需要的环境 请看 这很生动的说明了函数作为一等公民 充当返回值这个角色 现在我们想打一条log 就是调用这个新函数 或者说 我们还想把dbInfo这个新函数创建出来 道理也是一样的 不过这里我们又可以强调一下了 一定要是纯函数 如果不是 比如说dbInfo调用的时候有可能有对info甚至log产生副作用 这整个体系就崩塌了 可以说 柯里化就是这样一个神奇的工具 我们几乎可以只依靠它 又简洁又优雅的的解决特性与共性的问题 给予我们代码良好的复用性 灵活性 扩展性 理解起来 我们只需要牢牢记住 函数是一等公民 Function compose我们来复习高中知识 啥叫函数组合？很简单 f(x)是函数 那么 f(g(x))就是函数组合 1UI = f(r(state, action)) 12345const compose = function(f, g) &#123; return function(x) &#123; return f(g(x)); &#125;;&#125;; 我们的收获 Reasonable 很多人相信使用纯函数最大的好处是引用透明性（referential transparency）。如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么我们就说这段代码是引用透明的。由于纯函数总是能够根据相同的输入返回相同的输出，所以它们就能够保证总是返回同一个结果，这也就保证了引用透明性。 Cacheable 首先，纯函数总能够根据输入来做缓存。实现缓存的一种典型方式是 memoize 技术 值得注意的一点是，可以通过延迟执行的方式把不纯的函数转换为纯函数： 123var pureHttpCall = memoize(function(url, params)&#123; return function() &#123; return $.getJSON(url, params); &#125;&#125;); Portable / Self-Documenting 纯函数是完全自给自足的，它需要的所有东西都能轻易获得。 在 JavaScript 的设定中，可移植性可以意味着把函数序列化（serializing）并通过 socket 发送。也可以意味着代码能够在 web workers 中运行。总之，可移植性是一个非常强大的特性。命令式编程中“典型”的方法和过程都深深地根植于它们所在的环境中，通过状态、依赖和有效作用（available effects）达成；纯函数与此相反，它与环境无关，只要我们愿意，可以在任何地方运行它。你上一次把某个类方法拷贝到新的应用中是什么时候？我最喜欢的名言之一是 Erlang 语言的作者 Joe Armstrong 说的这句话：“面向对象语言的问题是，它们永远都要随身携带那些隐式的环境。你只需要一个香蕉，但却得到一个拿着香蕉的大猩猩…以及整个丛林”。 Testable 纯函数让测试更加容易。我们不需要伪造一个“真实的”支付网关，或者每一次测试之前都要配置、之后都要断言状态（assert the state）。只需简单地给函数一个输入，然后断言输出就好了。 Parallel 最后一点，也是决定性的一点：我们可以并行运行任意纯函数。因为纯函数根本不需要访问共享的内存，而且根据其定义，纯函数也不会因副作用而进入竞争态（race condition） One more thingFlux pattern View: representation layer. Controller views. Action: raise actions from representational layer. Dispatcher: receive actions and invoke callbacks. Store: respond to dispatched actions. Views controllers pattern Separate controllers(container components) and views(representational components) 几个肯定会被问到的问题：Q: In big team co-work, how to break projects down? (如果我们用函数式思考，一切非常自然) 回答这个问题，我建议大家先来这样思考我们的项目，想象成一个表格，或者数据库表，也就是一个二维的矩阵，一个维度是不同的业务实体，在这里就是不同种类的campaign；另一个维度与它垂直，就像是auth, i18n, theming，routing等等，你每一行代码的作用，就都可以用一个向量来表示：我这一行，是处理DSA的i18n。那么两种思考问题的方式其实就是一个地方不一样：把哪个维度看成行，把哪个维度看成列。 传统的方法是根据业务来思考的。而这里推荐的另一个看问题的角度，是通过可扩展性，可维护性，（说人话：呼应标题，让前端开发变简单）的方面来思考。这和数据库很类似：行扩展很简单，一条SQL语句即可，列扩展相对麻烦。所以我们用middleware来描述我们的列:一方面，借助柯里化，当我们需要扩展列（增加新的middleware）时，代价不那么大另一方面，当我们增加业务实体时（这是我们的主要工作，除了架构师）进行简单的行扩展 比方说 auth, i18n, theming，routing等等作为middleware避免了大量重复代码。我们平时在处理这些逻辑的时候，就算不是copy paste，互相之间的差别也不大，基本上是配置上的差别。 那么我们会问这样一个问题，如果我要在我们的项目中加入一个新的entity，举个例子，我们已经有了几种campaign，search campaign，shopping campaign等等，现在我们又要加入DSA campaign. 传统的做法是加入一个DSACampaignController,里面包含CRUD的actions，然后创建相应的View，templates，和campaignMT，adInsight MT integrate之后release，当然这些和之前其他campaign的code会有很多重复但是我们似乎也能接受（其实是习惯了） 按照上面的做法，是不是说我要在auth里添加一点DSA的配置，i18n里添加几个DSA的规则，说起来不用写完整的重复的controller啊之类的，但是这种散弹式的修改真的不是团队协作的毒药吗？怎么不像上面说的“行扩展”那样简单啊？回答： 设计出声明式编程的接口很难吗？设计出集中配置项的语法糖很难吗？最最简单的，有一个middleware来派送config给不同的middleware总能做到吧。 flux pattern中一个重要的角色是dispatcher，具体的应用中不同框架有不同的设计，但是功能都是：把不同的action分发到不同的store或者store里的不同字段。比方说一个简单的设计，不就是hash map吗？添加新的DSA campaign type，可以设计成为为这个新的entity action添加新的reducer（就是前面讲到的r的组件，或新的一组reducer） 当然由此还会有一个问题：如果维度不够用怎么办？拿业务上说就是：我们的business entity不一定是扁平的结构，就比如说，我们有不同type的campaign，这是一层，不同type的adgroup，ads， keywords等等，然后campaign,ads,keywords这些又是拿到一层考虑： flatten：可能很多时候我们并不需要关系这些业务上的树形关系，共性和特性就是柯里化中的小技巧了。数学上的分形，或者结合micro service的理念，通过子APP的方式来完成。 可能还是有点抽象，还是举projection grid中的例子吧： 不同场景下，datasource的不同，toolbar构造的不同，只体现在配置不同上。功能上的扩展，对于开发者来说，考虑两件事情（1）在哪里插入projection（2）插入什么样的projection 比如说，我们在product groups 中要用table的rows来体现业务上的树状层级，我们就加入一个tree-plugin（与product groups业务本身无关），我们考虑的是：在哪里pipe：修改structure projection pipe啥：加入parent node row在哪里pipe：修改content projection pipe啥：添加icon和缩进描述层级关系 How to compose async actions? 我只想回答这么一句话 1f_async(…args) ≡ f(condition, …args) How to share components to public? We share widgets and controls. we should not share business. We can share universal helper functions in typical pure function way. Pure functions are even easier to share: No side effects. Predicable","categories":[],"tags":[]},{"title":"Make UI development easy again","slug":"easy-ui","date":"2017-12-11T02:26:12.000Z","updated":"2017-12-22T05:28:27.608Z","comments":true,"path":"2017/12/11/easy-ui/","link":"","permalink":"http://yoursite.com/2017/12/11/easy-ui/","excerpt":"","text":"作为前端开发者经常有被其他领域的工程师质疑：“你整天都在忙啥。不就是写个UI有那么难么？”当然我们可以找出很多例子来证明UI真的可以很难很高科技，比如说amazon那个魔术一般的wunderbar，但是我们加班真的在忙这些东西吗？我猜测绝大多数人跟我一样，头疼的task和bug都来自于无穷无尽的entity CRUD，表单，表格当中。所以我个人是很想赞同他们的质疑：“前端真的有那么难吗？” It was easy若干年之前，我们并没有javascript，也没有SPA，那时的web应用开发是非常简单清晰的。我们以经典的ROR（ruby on rails, 很多被广泛的使用的框架，如structs，spring, Yii, asp.net都深受其影响）为例： 建表(当然production中这么建表被fire了后果自负) 123456CREATE TABLE user ( id int(11) NNOT NULL auto_increment, name varchar(255), password varchar(255), PRIMARY KEY (id)); model 1234567class User &lt; ApplicationRecord validates :name, presence: true before_create do self.name = login.capitalize if name.blank? endend view 12345&lt;%= form_tag(\"/login\", method: \"post\") do %&gt; &lt;%= text_field_tag(:name) %&gt; &lt;%= password_field_tag(:password) %&gt; &lt;%= submit_tag(\"Search\") %&gt;&lt;% end %&gt; 12&lt;h1&gt;Welcome&lt;/h1&gt;&lt;h3&gt;Hello: &lt;%= user.name %&gt;&lt;/h3&gt; controller 123456789class LoginsController &lt; ApplicationController def create if user = User.authenticate(params[:username], params[:password]) session[:current_user_id] = user.id redirect_to landing_url end endend 这一切很简单，在经典的MVC+serverside rendering的架构中，controller和model都是在server side运行,controller来管理business logic：调用哪个model（User），进行什么操作（authenticate），结果是什么（成功则跳转），model用来管理数据：User的字段,query（本例中映射到数据库）等操作。而view，很诚实的根据model里的数据来渲染页面，提交表单。我们没有JavaScript，发不出change，onClick事件，没有办法在view里面进行正则验证，这些逻辑都由controller完成。 Recap： UI = f(model),不会受其他data binding或者events的影响 view和controller之间划分了一条明显的界限 好处： 简单清晰，开发效率高，学习成本低 想象我们现在不用ejs作为模板引擎了，比如说用pug，controller基本不用啥改动。同样的，现在我们把db用mongodb替代mysql（事实上，我推荐个人小项目这么干），view基本不用改。 你换angular试试？把validate写进filter里:P 举一个现实的例子，在campaign ui从ui server migrate到SPA的过程中，我们在UI server端最费心的是什么？删掉这个controller会不会有request 404。实际上，如果不是这么大规模的替换，根本用不了这么担心，比如上面提到的换模板引擎或者换db已经够大了吧。不用说简单（呵呵）的修改逻辑或者修改用户体验。 换knockout呢？看不懂的console error等着你 why we move awayTo reduce UI friction!! 每次重新渲染页面的perf无法接受 复杂交互的需求：animation等 拿这写个gmail？微软的卧底才这么干。还是用angular吧=.= why we want it again?现在前端有大量MVC，MVVM框架，他们很优秀解决了无数的问题，但同时也引起开篇提出的质疑：现在前端是加班重灾区（jquery要接大锅，但与本文主题无关，略，并且相对于功劳，它不优雅之处并非主要）立下汗马功劳的events机制和data binding反过来在bite我们： hard bugs 在campaign creation的第一步和第四步，我们有两次让用户set buget的机会。如果我们让这两个budget control是一个instance:因为每一步的next和back button都会validate当前step所有的form,那么实际上，第一步和第四步的都执行了自己步骤以外的validation，这导致了很多bug；如果让他们是不同的instance，需要构造两次不说，其他受budget影响的component都需要监听或者分辨来自不同budget control的事件，或者判断传入的instance是不是当前想要的。数据和validation同步也是可能导致问题的。 DCR and rebranding 我们做了决定，deprecate monthly budget。然而 有很多已经存在的campaign apply了monthly budget， 所以settings页面需要保留monthly选项，creation页面需要删掉。 当我们已经在pilot 紧张的准备GA的时候，另外一个feature也要开始准备release了：shared budget。原来的budget control成为了一个child 和shared budget的control一起组成新的budget panel：所有的事件和接口，都需要转发。 painful debugging experience 我们有很多别的限制：不同的location，不同的language，budget的currency和limitation不一样，同时，bid是受到budget的限制的，traffic estimation是收到budget影响的。别忘了，我们有两个budget control，而且未来有可能，面包屑上方的header里，会出现第三个。别忘了，shared budget是和别的campaign关联的。budget除了value，还有type。是的，type还会变。你可以想象到我们在调试其中关于validation,关于filter，关于format，等等，bug的时候，不知道root cause在哪一脸懵逼的表情吗。 async 我们的render和destroy方法都是同步的。因为lazy loading的需求，我们需要在render的时候再加载一个第三方库，加载成功之后会创建一系列新的实体在其子节点上。destroy的时候，需要讲他们一一销毁：这时，一个很容易出bug的问题诞生了：你怎么知道destroy的时候render及其异步操作已经全部完成。稍不小心就会让程序进入无法预测的异常状态。 （1）改框架，render和destroy都支持promise。 好主意，加油（微笑）争取明年release（doge）（2）加全局flag 我们确实很多时候是怎么干的。 异步之后又fork出新的异步task怎么办 你怎么能保证线程安全？怎么能保证flag不被修改？如果之后的业务告诉你确实要修改flag怎么办？比如说，有两个同时进行的lazy loading。掀桌。 哦，对了，我们GA了之后，另外一个crew开始在我们的基础上做multiple language。原来language由enum，成为了数组或者enum。嗯。。。我们加班就是在干这样的事情的。 Make it easy againWe want both回想一下我们为什么放弃了那些田园时代美好的东西：1. perf 2. ux requirements 不就是把server sider rendering换成client side rendering嘛，其他的逻辑组织一切都不变，完全平移到client side。或者说用javascript强行写一个ror或者asp.net搁浏览器里跑，可行吗？ 当然可行，不过频繁的dom操作，依然让perf和体验不理想，可以归结为ui friction。好吧，我们写angular吧，我们写knockout吧，我们写backbone吧。 喷了一大圈，那些大神们果然还是比我们厉害啊。 Not a blocker now没想到现在我们迎来了一个大救星：virtual dom。放心的render，rerender吧，virtual dom刚我们干了reduce ui friction的活儿。咱们放心前进。 另一方面，对于很多局部的小控件，其实啊，重画是完全可以接受的，并不是ui friction，比方说，你就是一个小小的date picker之类的。 好了，现在我们可以回头找一下那一些被迫放弃的田园时代的美好吧。、 Recap： UI = f(model),不会受其他data binding或者events的影响 view和controller之间划分了一条明显的界限 How？状态递归controller是啥？描述状态转移的。compose出新的model 把这个新的model，交给新的view controller: old_model -&gt; new_model 根据什么计算？废话，传进来的参数啊。别的东西我看不见看不见。 1new_model = r(old_model, params) 在这里，我们并不像局限于某一种特定的pattern来讨论这些问题：viewmodel还是model，who cares？我们可以都叫他state params也太局限了，我们也不想局限于某一种代码组织方式，controller function？controller class？这不重要，我们是来推销哲学的。我们就叫它action吧。 敲黑板，划重点： 1state_next = r(state, action) r is a pure function!r is a pure function!r is a pure function! UI = f(state)和以上同样的想法，把model扩展成state状态得到。 1UI = f(state) f is a pure function!f is a pure function!f is a pure function! pure function what Given the same input, will always return the same output. 给定输入，则输出给定。 Produces no side effects. 没有副作用。 The simplest reusable building blocks of code in a program Immune to entire classes of bugs that have to do with shared mutable state Great candidates for parallel processing Easy to move around FP(functional programing)的数学背景(如果时间允许且听众感兴趣的话) (1) Category theory (解释了为什么pure function对干扰免疫，没有副作用)(思考问题的时候，一定注意把pure function理解成pipe，而不是execute，重点！pipe！) category: an algebraic structure that comprises “objects” that are linked by “arrows“ Consider the “category” as “container” which contains: values transforming of values (2) λ calc(lambda演算 然而JavaScript里的lambda 表达式不是真lambda表达式) λ-terms（解释了为什么“函数是一等公民”） variables: x function creation/abstraction: λx.E function application: E1 E2 evaluation（解释了柯里化的数学原理，解释了FP对于异步和并行的优势，启发我们不要用传统的考虑“值”的思路（call by value）去理解而是call by name） Alpha equivalence( or conversion ) Beta reduction call by value call by name why we want UI to be predicable we want UI transforming be predicable (不要拿随机数生成来抬杠，因为随机数的生成，是需要seed的) benefits Easy to control the order Easy to pass in additional data Easy to make reusable reduce functions How currying 123456789101112131415function log(status) &#123; return function(context) &#123; return function(message) &#123; // fancy logging code here &#125;; &#125;;&#125;var info = log('info'); // create a new function \"info\" by fixing first argumentinfo('db-context')('message');log('other level')('some context')('a message'); // use the original function directly with all argumentsvar dbInfo = info('db'); // create a new function againdbInfo('something happened'); partial 1234567891011function log(status, context, message) &#123; // fancy logging code here&#125;function info(context, message) &#123; return log('info', context, message);&#125;function dbInfo(message) &#123; return info('db', message);&#125; immutable Some side effects avoided. Pure functions easier to write. Fast change detection. Immutable data can be safely cached. Easier to implement undo. Concurrency. Deep in r - centralized state management state is read-only It is immutability all changes are centralized and happen one by one in a strict order Easy to be logged, serialized, stored, and later replayed for debugging or testing purposes. Changes are made with pure functions Deep in f - UI as function of state One-way data binding single source of truth 我们之前遇到的各种前端框架显然不满足f(Status) = UI，通常来说，应该是 f(Status, 用户交互，推送信息，其他UI联动变化，……) = UI 那么React必然要做的事情就是实现一个:g(上面其他因素) = status，这就是需要单向数据流的原因。 我个人的体会，因为可能已经习惯了诸如knockout、angularjs等成熟的框架提供的各种完善的two-way data-binding的机制，第一眼很难接受React的one-way data flow，而且写一些很小的component的时候（比如hello world之类的），会发现很简单的事情反而需要我们花一些额外的精力。 比如一个最简单的input框，如果用ko，只需要把他和vm上一个observable绑定就好了，在ng中也是很简单的ng-model=xxx，但是突然React告诉你，不行，你要绕一圈，你的输入只能作用于status的update，绕一圈才能回到UI的变化，当然不习惯。 Facebook的工程师们肯定不是吃饱了撑的才这样设计。我们可以想象一些稍微复杂的逻辑——比如，如果这个input框需要把用户的输入全部转成大写字母，或者拒绝掉一些非法字符。当然，现在的框架已经足够优秀，我们可以pass in各种custom filter。问题就在于当这些需求一个一个堆砌起来，逻辑就会逐渐变得混乱，filter，suscription，events等等聚集在一起，代码的可读性会严重降低且难以维护。当UI中的元素越来越多，业务越来越复杂，这些不便利之处会指数级爆炸。而单向的数据流就不存在这些问题了，flux中有一个很好的Dispature和Store的概念，就像现代物流的集散分拣中心一样的（此处谢绝抬杠），一件快递的时候看起来不必要，但是成千上万的数据涌来，他依然能把所有的东西处理得井井有条，所有的东西就像阅兵式上的方阵，清晰有条理。我们会被从filter，suscription，events中被拯救出来，只有两样简单的事情：status，UI。 Tail我们不是来sell某一种框架或者技术的。更多的是想抛砖引玉，启发大家如何借助一些最新的力量，在保留我们已有的财富的同时，找到一次前端的“文艺复新”。当然和文艺复新一样，这里也是旧瓶装新酒。这里的flux pattern和传统的MVC相比，也有了不少变化，下面会说明。 可能喜欢在技术上赶时髦的同学已经想把那几个框架或者技术的名字呼之欲出了。但是这不是这里想要deliver的东西。这里只是讲一种pattern，我们更希望它随时随地，哪怕我们在处理没有用那些新的框架的时候，也能启发我们，让我们的工作更加简单。用到的时候，更能体会作者的良苦用心，为什么这样做，而不是API的搬运工。事实上，这种思考问题的方法，这种设计的思路，真的不需要通过哪个框架或者技术才能实现。Jquery？Why not？ case study: projection-grid predicable: 只要projection确定了，内容就确定。 renderer并不关注projection如何被pipe，如何被compose，只需要关心render model长什么样子就能画出grid React，vue，backbone版本只是renderer不一样，如何计算render model完全不用重复。所以：不同情形下可以重用同一份plugin！ Debug：只需要关注render model，就能查找是compose model发生的错误还是在render时发生。 Test：对于core，只需要关注IO，对于renderer，只需要关注给定render model之后的snapshot。 Extensibility: 通过pipe更多的plugin。plugin是pure function或plain object(这是语法糖，实际上我们都处理成reducer，即，根据现有配置和参数（state and action）返回新的配置（new state）) Flux pattern View: representation layer. Controller views. Action: raise actions from representational layer. Dispatcher: receive actions and invoke callbacks. Store: respond to dispatched actions. Controller Views Pattern Separate controllers(container components) and views(representational components) Benefits More portable. Less cognitive overhead. Easier testing. Frequende asked questions:Q: how to share components to public?A: We share widgets and controls. we should not share business. We can share universal helper functions in typical pure function way. Pure functions are even easier to share: No side effects. Predicable Higher ordered components. Q: how to compose async actions?A:这不就是λx condition的问题吗？柯里化。看似复杂的问题背后一定有简单的数学原理。 Q: In big team co-work, how to break projects down?A Trandional: application -&gt; modules -&gt; controllers + views + models(viewmodels) | MVVM or other patterns Applying middleware:(如果我们用函数式思考，一切非常自然) application = middleware1(middleware2(middleware3(…midlewareN(config)))) or application = middleware1(config1)(middleware2(config2))(…)(middlewareN(configN)) (如果我们用函数式思考，一切非常自然) 回答这个问题，我建议大家先来这样思考我们的项目，想象成一个表格，或者数据库表，也就是一个二维的矩阵，一个维度是不同的业务实体，在这里就是不同种类的campaign；另一个维度与它垂直，就像是auth, i18n, theming，routing等等，你每一行代码的作用，就都可以用一个向量来表示：我这一行，是处理DSA的i18n。那么两种思考问题的方式其实就是一个地方不一样：把哪个维度看成行，把哪个维度看成列。 传统的方法是根据业务来思考的。而这里推荐的另一个看问题的角度，是通过可扩展性，可维护性，（说人话：呼应标题，让前端开发变简单）的方面来思考。这和数据库很类似：列扩展很简单，一条SQL语句即可，行扩展相对麻烦。所以我们用middleware来描述我们的列:一方面，借助柯里化，当我们需要扩展列（增加新的middleware）时，代价不那么大另一方面，当我们增加业务实体时（这是我们的主要工作，除了架构师）进行简单的行扩展 比方说 auth, i18n, theming，routing等等作为middleware避免了大量重复代码。我们平时在处理这些逻辑的时候，就算不是copy paste，互相之间的差别也不大，基本上是配置上的差别。 那么我们会问这样一个问题，如果我要在我们的项目中加入一个新的entity，举个例子，我们已经有了几种campaign，search campaign，shopping campaign等等，现在我们又要加入DSA campaign. 传统的做法是加入一个DSACampaignController,里面包含CRUD的actions，然后创建相应的View，templates，和campaignMT，adInsight MT integrate之后release，当然这些和之前其他campaign的code会有很多重复但是我们似乎也能接受（其实是习惯了） 按照上面的做法，是不是说我要在auth里添加一点DSA的配置，i18n里添加几个DSA的规则，说起来不用写完整的重复的controller啊之类的，但是这种散弹式的修改真的不是团队协作的毒药吗？怎么不像上面说的“行扩展”那样简单啊？回答： 设计出声明式编程的接口很难吗？设计出集中配置项的语法糖很难吗？最最简单的，有一个middleware来派送config给不同的middleware总能做到吧。 flux pattern中一个重要的角色是dispatcher，具体的应用中不同框架有不同的设计，但是功能都是：把不同的action分发到不同的store或者store里的不同字段。比方说一个简单的设计，不就是hash map吗？添加新的DSA campaign type，可以设计成为为这个新的entity action添加新的reducer（就是前面讲到的r的组件，或新的一组reducer） 当然由此还会有一个问题：如果维度不够用怎么办？拿业务上说就是：我们的business entity不一定是扁平的结构，就比如说，我们有不同type的campaign，这是一层，不同type的adgroup，ads， keywords等等，然后campaign,ads,keywords这些又是拿到一层考虑： flatten：可能很多时候我们并不需要关系这些业务上的树形关系，共性和特性就是柯里化中的小技巧了。数学上的分形，或者结合micro service的理念，通过子APP的方式来完成。 可能还是有点抽象，还是举projection grid中的例子吧： 不同场景下，datasource的不同，toolbar构造的不同，只体现在配置不同上。功能上的扩展，对于开发者来说，考虑两件事情（1）在哪里插入projection（2）插入什么样的projection 比如说，我们在product groups 中要用table的rows来体现业务上的树状层级，我们就加入一个tree-plugin（与product groups业务本身无关），我们考虑的是：在哪里pipe：修改structure projection pipe啥：加入parent node row在哪里pipe：修改content projection pipe啥：添加icon和缩进描述层级关系","categories":[],"tags":[]},{"title":"Data binding: hijack and dependencies collection","slug":"deps-collection","date":"2017-10-18T02:22:55.000Z","updated":"2017-10-18T07:34:10.209Z","comments":true,"path":"2017/10/18/deps-collection/","link":"","permalink":"http://yoursite.com/2017/10/18/deps-collection/","excerpt":"","text":"见过的前端js框架，data-binding的实现方案大致有三种： 直接把数据的暴露成function,如knockout dirty check, 如angular 劫持getter,setter + 依赖收集,如vue 写下第三种： Vue 源码 我们的demo code是这样的： 1234form input(type=&quot;text&quot;, v-bind=&quot;count&quot;) button(type=&quot;button&quot;, v-click=&quot;increment&quot;) incrementdiv(v-bind=&quot;count&quot;) 123456789101112131415161718import &#123; Observable, Watcher &#125; from '@bingads-webui/simple-observable';const person = new Observable(&#123; firstName: 'Michael', lastName: 'Jordan',&#125;);new Watcher(person, 'fullName', () =&gt; &#123; return `$&#123;person.firstName&#125; $&#123;person.lastName&#125;`;&#125;, (val) =&gt; &#123; console.log(`The full name is $&#123;val&#125;`);&#125;);console.log(person.fullName);person.lastName = 'Jackson';window.person = person; 带dom操作的: 123456789101112131415import &#123; App &#125; from '@bingads-webui/simple-observable';import template from './index.pug';new App(&#123; el: document.body, template, data: &#123; count: 3, &#125;, method: &#123; increment: function() &#123; this.data.count++; &#125; &#125;,&#125;); Observable在属性被读写的时候主动通知：1234567891011121314151617const person = &#123;&#125;;let firstName = 'Michael';Object.defineProperty(person, 'firstName', &#123; get() &#123; console.log('Reading person.firstName'); return 'Michael'; &#125;, set(val) &#123; console.log(`Setting person.firstName $&#123;val&#125;`); firstName = val; &#125;&#125;); 我们可以定义最基本的observable类和defineReactive方法： 12345678910111213141516171819202122232425function defineReactive(obj, key, val) &#123; Object.defineProperty(obj, key, &#123; get() &#123; // todo return val; &#125;, set(newVal) &#123; // todo val = newVal; &#125;, &#125;);&#125;function obervable(obj) &#123; const keys = Object.keys(obj); keys.forEach((key) =&gt; &#123; defineReactive(obj, key, obj[key]); &#125;); return obj;&#125; Refactor一下，写成class 12345678910111213141516171819202122232425262728293031class Observable &#123; constructor(obj) &#123; return this.walk(obj); &#125; walk(obj) &#123; const keys = Object.keys(obj); keys.forEach((key) =&gt; &#123; this.defineReactive(obj, key, obj[key]); &#125;); return obj; &#125; defineReactive(obj, key, val) &#123; Object.defineProperty(obj, key, &#123; get() &#123; // todo return val; &#125;, set(newVal) &#123; // todo val = newVal; &#125;, &#125;); &#125;&#125; Watcher现在来实现demo中的这个部分： 123new Watcher(person, 'fullName', () =&gt; &#123; return `$&#123;person.firstName&#125; $&#123;person.lastName&#125;`;&#125;); (有没有觉得和dirty check里面的$$watchers很像。。。后面还有更像的) watcher属性无法被赋值 watcher的值由第三个参数决定 123456789101112function watcher(obj, key, getVal) &#123; Object.defineProperty(obj, key, &#123; get() &#123; const val = getVal(); return val; &#125;, set() &#123; throw new Error('Cannot set values of wathers.'); &#125; &#125;)&#125; 改写成watcher类并加入listener 123456789101112131415161718192021222324252627282930313233class Watcher &#123; constructor(obj, key, cb， onComputedUpdate) &#123; this.obj = obj; this.key = key; this.cb = cb; this.onComputedUpdate = onComputedUpdate; return this.defineComputed(); &#125; defineComputed() &#123; const self = this; const onDepUpdated = () =&gt; &#123; const val = self.cb(); this.onComputedUpdate(val); &#125;; Object.defineProperty(this.obj, this.key, &#123; get() &#123; const val = self.cb(); this.onComputedUpdate(val); return val; &#125;, set() &#123; throw new Error('Cannot set values of wathers.'); &#125;, &#125;); &#125;&#125; 这样observable和watcher就可以一起工作了： 123const person = new Observable(&#123; firstName: 'Michael', lastName: 'Jordan' &#125;);new Watcher(person, 'fullName', () =&gt; `$&#123;person.firstName&#125; $&#123;person.lastName&#125;`, (val) =&gt; &#123; console.log(`new value $&#123;val&#125;`) &#125;); Dependencies collection这样有一个问题：我们是主动去取fullName的值的时候，它才会被计算。而我们期望的行为，是firstName或者lastName被修改的时候，主动通知fullName，并更新,触发onComputedUpdate。可以设计这样一个dependency collector, 来收集所有的dependencies. 具体一点就是,让一个observable知道有哪些watcher依赖它,并且在自己被赋值的时候通知watcher. 注意到watcher的getter被call到的时候,它依赖哪些observable,就会call到这些observable,可以用这个时机来告诉observable,这个watcher依赖你了.然后在call到setter时,就可以把dependencies拿出来通知: 简单版本,拿一个全局变量存dependencies做依赖收集器 123const Dep = &#123; target: null,&#125;; 在watcher中: 12345678910111213141516171819defineComputed() &#123; const self = this; Object.defineProperty(this.obj, this.key, &#123; get() &#123; Dep.target = () =&gt; &#123; const val = self.cb(); this.onComputedUpdate(val); &#125; const val = self.cb(); return val; &#125;, set() &#123; throw new Error('Cannot set values of wathers.'); &#125;, &#125;);&#125; 在observable中 123456789101112131415defineReactive(obj, key, val) &#123; const deps = []; Object.defineProperty(obj, key, &#123; get() &#123; deps.push(Dep.target); return val; &#125;, set(newVal) &#123; val = newVal; deps.forEach(dep =&gt; dep()); &#125;, &#125;); 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147import _ from 'underscore';class Dep &#123; constructor() &#123; this.deps = []; &#125; depend() &#123; if (Dep.target &amp;&amp; this.deps.indexOf(Dep.target) === -1) &#123; this.deps.push(Dep.target); &#125; &#125; notify() &#123; this.deps.forEach((dep) =&gt; &#123; dep(); &#125;); &#125;&#125;Dep.target = null;export class Observable &#123; constructor(obj) &#123; return this.walk(obj); &#125; walk(obj) &#123; const keys = Object.keys(obj); keys.forEach((key) =&gt; &#123; this.defineReactive(obj, key, obj[key]); &#125;); return obj; &#125; defineReactive(obj, key, val) &#123; const dep = new Dep(); Object.defineProperty(obj, key, &#123; get() &#123; dep.depend(); return val; &#125;, set(newVal) &#123; val = newVal; dep.notify(); &#125;, &#125;); &#125;&#125;export class Watcher &#123; constructor(obj, key, cb, onComputedUpdate) &#123; this.obj = obj; this.key = key; this.cb = cb; this.onComputedUpdate = onComputedUpdate; return this.defineComputed(); &#125; defineComputed() &#123; const self = this; const onDepUpdated = () =&gt; &#123; const val = self.cb(); this.onComputedUpdate(val); &#125;; Object.defineProperty(this.obj, this.key, &#123; get() &#123; Dep.target = onDepUpdated; const val = self.cb(); Dep.target = null; return val; &#125;, set() &#123; throw new Error('Cannot assign value computed!'); &#125;, &#125;); &#125;&#125;export class App &#123; constructor(&#123; el, template, data, method &#125;) &#123; this.el = el; this.template = template; this.data = new Observable(data); this.method = method; this.render(); this.applyBindings(); &#125; applyBindings() &#123; const bindList = this.el.querySelectorAll('[v-bind]'); _.each(bindList, (bind) =&gt; &#123; const bindKey = bind.getAttribute('v-bind'); if (bind.tagName === 'INPUT') &#123; // bind.value = this.data[bindKey]; new Watcher(this.data, `$$&#123;bindKey&#125;Value`, () =&gt; &#123; return this.data[bindKey]; &#125;, (newVal) =&gt; &#123; bind.value = newVal; &#125;); bind.value = this.data[`$$&#123;bindKey&#125;Value`]; bind.addEventListener('input', (e) =&gt; &#123; this.data[bindKey] = e.target.value; &#125;); &#125; else &#123; new Watcher(this.data, `$$&#123;bindKey&#125;InnerHtml`, () =&gt; &#123; return this.data[bindKey]; &#125;, (newVal) =&gt; &#123; bind.innerHTML = newVal; &#125;); bind.innerHTML = this.data[`$$&#123;bindKey&#125;InnerHtml`]; &#125; &#125;); const clickList = this.el.querySelectorAll('[v-click]'); _.each(clickList, (click) =&gt; &#123; const clickKey = click.getAttribute('v-click'); const clickFunc = this.method[clickKey]; click.onclick = clickFunc.bind(this); &#125;); &#125; render() &#123; this.el.innerHTML = this.template(); &#125;&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"framework","slug":"framework","permalink":"http://yoursite.com/tags/framework/"},{"name":"data binding","slug":"data-binding","permalink":"http://yoursite.com/tags/data-binding/"}]},{"title":"data-binding: dirty check","slug":"dirty-check","date":"2017-10-11T07:31:04.000Z","updated":"2017-10-17T11:03:02.022Z","comments":true,"path":"2017/10/11/dirty-check/","link":"","permalink":"http://yoursite.com/2017/10/11/dirty-check/","excerpt":"","text":"见过的前端js框架，data-binding的实现方案大致有三种： 直接把数据的暴露成function,如knockout dirty check, 如angular 劫持getter,setter + 依赖收集,如vue 自己实现了一个非常简化的dirty-check $$watchersscope是angular中最重要的一个概念，这里不再重复。用dirty check来实现data binding,scope中的$$watchers起到了核心的作用。$$watchers是一个数组，用于存放scope下所有的数据。每个数据有以下几个字段： name: 变量名，就是$scope.someName中的someName last: 变量上一次的值，这是一个值。 newVal: 获取新值的函数，这是个函数。 listener: 监听的回掉函数。 $watch将一个新的成员加入$$watchers 12345678$watch(name, exp, listener = function () &#123;&#125;) &#123; this.$$watchers.push(&#123; name, last: '', newVal: exp, listener, &#125;);&#125; 有了$watch方法，我们就可以把scope中的所有值都加入$$watchers: 12345for (const key in $scope) &#123; if (key != '$$watchers' &amp;&amp; !_.isFunction($scope[key])) &#123; $scope.$watch(key, () =&gt; $scope[key]); &#125;&#125; $digest$digest的作用，就是遍历$$watchers里所有的值，比较新值和旧值，调用listener，并把新值赋值给last,直到所有的新值旧值都相等。 123456789101112131415161718$digest() &#123; let dirty = true; while (dirty) &#123; dirty = false; _.each(this.$$watchers, (watcher) =&gt; &#123; const newVal = watcher.newVal(); const oldVal = watcher.last; if (newVal !== oldVal &amp;&amp; !_.isNaN(newVal) &amp;&amp; !_.isNaN(oldVal)) &#123; dirty = true; watcher.listener(oldVal, newVal); watcher.last = newVal; &#125; &#125;); &#125;&#125; 再加入更新dom元素的逻辑，就变成了 12345678910111213141516171819202122232425262728293031$digest() &#123; const bindList = document.querySelectorAll('[ng-bind]'); let dirty = true; while (dirty) &#123; dirty = false; _.each(this.$$watchers, (watcher) =&gt; &#123; const newVal = watcher.newVal(); const oldVal = watcher.last; if (newVal !== oldVal &amp;&amp; !_.isNaN(newVal) &amp;&amp; !_.isNaN(oldVal)) &#123; dirty = true; watcher.listener(oldVal, newVal); watcher.last = newVal; _.each(bindList, (bind) =&gt; &#123; const modelName = bind.getAttribute('ng-bind'); if (modelName === watcher.name) &#123; if (bind.tagName === 'INPUT') &#123; bind.value = this[modelName]; &#125; else &#123; bind.innerHTML = this[modelName]; &#125; &#125; &#125;); &#125; &#125;); &#125; &#125; 绑定到dom剩余的工作就是把一些dom事件绑定一下，这里简单的绑定一下click button和inputbox的change 1234567891011121314151617const clickBindList = document.querySelectorAll('[ng-click]');_.each(clickBindList, (clickBind) =&gt; &#123; clickBind.onclick = () =&gt; &#123; $scope[clickBind.getAttribute('ng-click')](); $scope.$digest(); &#125;;&#125;);const inputList = document.querySelectorAll('input[ng-bind]');_.each(inputList, (input) =&gt; &#123; input.addEventListener('input', () =&gt; &#123; $scope[input.getAttribute('ng-bind')] = input.value; $scope.$digest(); &#125;);&#125;); 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import _ from 'underscore';class Scope &#123; constructor() &#123; this.$$watchers = []; &#125; $watch(name, exp, listener = function () &#123;&#125;) &#123; this.$$watchers.push(&#123; name, last: '', newVal: exp, listener, &#125;); &#125; $digest() &#123; const bindList = document.querySelectorAll('[ng-bind]'); let dirty = true; while (dirty) &#123; dirty = false; _.each(this.$$watchers, (watcher) =&gt; &#123; const newVal = watcher.newVal(); const oldVal = watcher.last; if (newVal !== oldVal &amp;&amp; !_.isNaN(newVal) &amp;&amp; !_.isNaN(oldVal)) &#123; dirty = true; watcher.listener(oldVal, newVal); watcher.last = newVal; _.each(bindList, (bind) =&gt; &#123; const modelName = bind.getAttribute('ng-bind'); if (modelName === watcher.name) &#123; if (bind.tagName === 'INPUT') &#123; bind.value = this[modelName]; &#125; else &#123; bind.innerHTML = this[modelName]; &#125; &#125; &#125;); &#125; &#125;); &#125; &#125;&#125;export function ngController(controller) &#123; const $scope = new Scope(); controller($scope); const clickBindList = document.querySelectorAll('[ng-click]'); _.each(clickBindList, (clickBind) =&gt; &#123; clickBind.onclick = () =&gt; &#123; $scope[clickBind.getAttribute('ng-click')](); $scope.$digest(); &#125;; &#125;); const inputList = document.querySelectorAll('input[ng-bind]'); _.each(inputList, (input) =&gt; &#123; input.addEventListener('input', () =&gt; &#123; $scope[input.getAttribute('ng-bind')] = input.value; $scope.$digest(); &#125;); &#125;); for (const key in $scope) &#123; if (key != '$$watchers' &amp;&amp; !_.isFunction($scope[key])) &#123; $scope.$watch(key, () =&gt; $scope[key]); &#125; &#125; $scope.$digest();&#125;; Demo123456ngController(($scope) =&gt; &#123; $scope.count = 0; $scope.increment = () =&gt; &#123; $scope.count++; &#125;;&#125;);","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"framework","slug":"framework","permalink":"http://yoursite.com/tags/framework/"},{"name":"data binding","slug":"data-binding","permalink":"http://yoursite.com/tags/data-binding/"}]},{"title":"Object.defineProperty","slug":"defineObject-and-observable-watch","date":"2017-09-27T12:26:26.000Z","updated":"2017-09-27T12:43:16.062Z","comments":true,"path":"2017/09/27/defineObject-and-observable-watch/","link":"","permalink":"http://yoursite.com/2017/09/27/defineObject-and-observable-watch/","excerpt":"","text":"Object.defineProperty在js中我们用可以用这样几种方法定义属性： 1foo.bar = 'abc'; 1foo['bar'] = 'abc'; 123Object.defineProperty(foo, 'bar', &#123; value: 'abc',&#125;); defineProperty(MDN链接)这种方法，最麻烦，最强大. 语法1Object.defineProperty(obj, prop, descriptor) 参数 obj: 需要被操作的目标对象 prop: 目标对象需要定义或修改的属性的名称 descriptor: 将被定义或修改的属性的描述符。 返回值被传递给函数的对象 descriptor之前列出来的比较简单的两种写法，是通过赋值来创建并显示在属性枚举中（for...in或Object.keys），可以被修改，也可以被删除。使用definePropery,可以控制这些： configurable: 这个值为true时，descriptor才可以被修改，同时这个property也能从obj上被删除。默认为false。 enumerable: 这个值为true时，才可以出现在for...in或者Object.keys中 value: property的值。默认undefined。 writable: 这个值为true时，propery才能被赋值运算符改变。默认false。 get/set: 就跟其他的getter/setter差不多，包括es6的getter/setter","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"Backbone model- on vs listenTo","slug":"on-vs-listenTo","date":"2017-07-10T09:06:50.000Z","updated":"2017-07-10T09:33:21.001Z","comments":true,"path":"2017/07/10/on-vs-listenTo/","link":"","permalink":"http://yoursite.com/2017/07/10/on-vs-listenTo/","excerpt":"","text":"发现好久没有写blog了 要捡回来这个好习惯：） 今天遇到了一个bug，给一个全局的（不要吐槽,legacy code留下来的全局的东西没那么好消灭干净）添加了一个事件的callback，大致代码是这样 123aGlobalModel.on('a-event', () =&gt; &#123; someView.doSomething();&#125;); 原因是，someView被remove的时候，忘了call gGlabal.off. Ok, 加上off逻辑当然不难，但是： 直接call off会清理掉所有的handler。这坑爹货是全局的。。。。 可以指定off哪一个callback，所以这个callback会被传来传去。。比方说有很多处会remove的情况。on 并不是在someView里定义的。 事实上，listenTo是一个更好的选择。 123someView.listenTo(aGlobalModel, 'a-event', () =&gt; &#123; // ...code&#125;) 当someView的remove被call到的时候 会自动的执行stopListening. 看一下Backbone源码 on 12345678910111213141516171819// Bind an event to a `callback` function. Passing `\"all\"` will bind// the callback to all events fired.Events.on = function(name, callback, context) &#123; this._events = eventsApi(onApi, this._events || &#123;&#125;, name, callback, &#123; context: context, ctx: this, listening: _listening &#125;); if (_listening) &#123; var listeners = this._listeners || (this._listeners = &#123;&#125;); listeners[_listening.id] = _listening; // Allow the listening to use a counter, instead of tracking // callbacks for library interop _listening.interop = false; &#125; return this;&#125;; listenTo 1234567891011121314151617181920212223242526// Inversion-of-control versions of `on`. Tell *this* object to listen to// an event in another object... keeping track of what it's listening to// for easier unbinding later.Events.listenTo = function(obj, name, callback) &#123; if (!obj) return this; var id = obj._listenId || (obj._listenId = _.uniqueId('l')); var listeningTo = this._listeningTo || (this._listeningTo = &#123;&#125;); var listening = _listening = listeningTo[id]; // This object is not listening to any other events on `obj` yet. // Setup the necessary references to track the listening callbacks. if (!listening) &#123; this._listenId || (this._listenId = _.uniqueId('l')); listening = _listening = listeningTo[id] = new Listening(this, obj); &#125; // Bind callbacks on obj. var error = tryCatchOn(obj, name, callback, this); _listening = void 0; if (error) throw error; // If the target obj is not Backbone.Events, track events manually. if (listening.interop) listening.on(name, callback); return this;&#125;; 上述代码中用到的eventsApi,是标准的事件，回调迭代器： 12345678910111213141516171819202122// Iterates over the standard `event, callback` (as well as the fancy multiple// space-separated events `\"change blur\", callback` and jQuery-style event// maps `&#123;event: callback&#125;`).var eventsApi = function(iteratee, events, name, callback, opts) &#123; var i = 0, names; if (name &amp;&amp; typeof name === 'object') &#123; // Handle event maps. if (callback !== void 0 &amp;&amp; 'context' in opts &amp;&amp; opts.context === void 0) opts.context = callback; for (names = _.keys(name); i &lt; names.length ; i++) &#123; events = eventsApi(iteratee, events, names[i], name[names[i]], opts); &#125; &#125; else if (name &amp;&amp; eventSplitter.test(name)) &#123; // Handle space-separated event names by delegating them individually. for (names = name.split(eventSplitter); i &lt; names.length; i++) &#123; events = iteratee(events, names[i], callback, opts); &#125; &#125; else &#123; // Finally, standard events. events = iteratee(events, name, callback, opts); &#125; return events;&#125;;","categories":[],"tags":[{"name":"Framework","slug":"Framework","permalink":"http://yoursite.com/tags/Framework/"},{"name":"Backbone","slug":"Backbone","permalink":"http://yoursite.com/tags/Backbone/"},{"name":"Events","slug":"Events","permalink":"http://yoursite.com/tags/Events/"}]},{"title":"es6-generator","slug":"es6-generator","date":"2017-03-24T08:54:15.000Z","updated":"2017-03-31T02:26:32.766Z","comments":true,"path":"2017/03/24/es6-generator/","link":"","permalink":"http://yoursite.com/2017/03/24/es6-generator/","excerpt":"","text":"看babel官网上提供的例子 123456789101112131415161718var fibonacci = &#123; [Symbol.iterator]: function*() &#123; var pre = 0, cur = 1; for (;;) &#123; var temp = pre; pre = cur; cur += temp; yield cur; &#125; &#125;&#125;for (var n of fibonacci) &#123; // truncate the sequence at 1000 if (n &gt; 1000) break; console.log(n);&#125; 在for…of…循环中，会调用迭代器对象的迭代器方法。之前那篇迭代器有提到过，但是这里的function*和普通的函数function不一样。如果是普通的函数，不管什么时候执行，得到的结果总是一样的（不考虑全局变量之类的干扰），或者说，和上一次无关。","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"ES6(ES2015)","slug":"ES6-ES2015","permalink":"http://yoursite.com/tags/ES6-ES2015/"}]},{"title":"Javascript中的稀疏数组 sparse arrays vs. 密集数组 dense arrays","slug":"dense-arrays","date":"2017-03-21T06:49:41.000Z","updated":"2017-03-23T06:09:27.267Z","comments":true,"path":"2017/03/21/dense-arrays/","link":"","permalink":"http://yoursite.com/2017/03/21/dense-arrays/","excerpt":"","text":"大多数情况下，javascript中的数组是稀疏数组（其实就是k-v pairs），也就是说a[0], a[100]存在，但是a[1]到a[99]可能都不存在。 不存在，不是说存在但是是undefined,就是真正的不存在:如果用foreach访问并console.log，会发现根本没有这么一项，而不是输出一个undefined 实际上,JavaScript并没有常规的数组,所有的数组其实就是个对象,只不过会自动管理一些”数字”属性和length属性罢了.说的更直接一点,JavaScript中的数组根本没有索引,因为索引应该是数字,而JavaScript中数组的索引其实是字符串.arr[1]其实就是arr[“1”],给arr[“1000”] = 1,arr.length也会自动变为1001.这些表现的根本原因就是,JavaScript中的对象就是字符串到任意值的键值对.注意键只能是字符串 sparse arrays 得到一个稀疏数组 1var sparseArr1 = new Array(3); 1234var sparseArr2 = [];sparseArr2[0] = 1;sparseArr2[100] = 100; 遍历稀疏数组，所有的“空隙”会被跳过123456var sparseArr2 = [];sparseArr2[0] = 1;sparseArr2[100] = 100;sparseArr2.forEach(function(index, val) &#123; console.log(index); console.log(val) &#125;) // output: 1 0 100 100 dense arrays 得到一个密集数组 1Array(undefined, undefined, undefined) 1var denseArr1 = Array.apply(null, Array(3))； 1var denseArr2 = Array.apply(null, Array(3)).map(Function.prototype.call.bind(Number))","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"ES6 - destructuring 整体析构赋值","slug":"destructuring","date":"2017-03-20T13:18:57.000Z","updated":"2017-03-24T08:56:38.188Z","comments":true,"path":"2017/03/20/destructuring/","link":"","permalink":"http://yoursite.com/2017/03/20/destructuring/","excerpt":"","text":"这个汉化——“ 整体析构赋值”——是抄的，我真的翻译不来。。。 Array// list matching 1234const [a, ,b] = [1,2,3];a === 1;b === 3; Object12345const obj = &#123; a: 1, b: 2, c: 3&#125;;const &#123;a, c&#125; = obj;a === 1;c === 3; function parameters Can be used in parameter position 1234function g(&#123;name: x&#125;) &#123; console.log(x);&#125;g(&#123;name: 5&#125;) Work with default args 1234function r(&#123;x, y, w = 10, h = 10&#125;) &#123; return x + y + w + h;&#125;r(&#123;x:1, y:2&#125;) === 23","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"ES6(ES2015)","slug":"ES6-ES2015","permalink":"http://yoursite.com/tags/ES6-ES2015/"}]},{"title":"iterators & for...of... es6迭代器","slug":"iterators","date":"2017-03-16T14:01:56.000Z","updated":"2017-03-20T13:21:47.098Z","comments":true,"path":"2017/03/16/iterators/","link":"","permalink":"http://yoursite.com/2017/03/16/iterators/","excerpt":"","text":"用for…in…一定要小心！！12345var myArray = [1, 2, 3, 4, 5];for (var index in myArray) &#123; // never do this!! console.log(myArray[index]);&#125; index不是number而是string，说不定就让自己掉进 ‘2’ + 1 == ‘21’ 这样的bug里了 for-in还会作用于自定义属性（myArray.name这种） 有些时候顺序是随机的 简而言之，for-in是为普通对象设计的，你可以遍历得到字符串类型的键，因此不适用于数组遍历 .forEach的局限123myArray.forEach(funciton(val) &#123; console.log(val);&#125;) 不能使用break语句中断循环，也不能使用return语句返回到外层函数 for…of in es6 正确响应break, continue 避免for…in的缺点 除了Array, 还可以遍历String, map, set 迭代器对象for-of循环语句通过方法调用来遍历各种集合。数组、Maps对象、Sets对象以及其它在我们讨论的对象有一个共同点，它们都有一个迭代器方法。 你可以给任意类型的对象添加迭代器方法。 当你为对象添加myObject.toString()方法后，就可以将对象转化为字符串，同样地，当你向任意对象添加myObjectSymbol.iterator方法，就可以遍历这个对象了 for-of循环首先调用集合的Symbol.iterator方法，紧接着返回一个新的迭代器对象。迭代器对象可以是任意具有.next()方法的对象；for-of循环将重复调用这个方法，每次循环调用一次","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"event flow","slug":"event-flow","date":"2017-03-15T02:23:36.000Z","updated":"2017-03-20T08:27:02.220Z","comments":true,"path":"2017/03/15/event-flow/","link":"","permalink":"http://yoursite.com/2017/03/15/event-flow/","excerpt":"","text":"流 Flow - 事件流 event flow简单来说 流就是具有方向的数据事件流所描述的就是从页面中接受事件的顺序。 事件冒泡事件冒泡即事件开始时，由最具体的元素接收（也就是事件发生所在的节点），然后逐级传播到较为不具体的节点 事件捕获当某个事件发生时，父元素应该更早接收到事件，具体元素则最后接收到事件 addEventListener1element.addEventListener(event, function, useCapture) 第一个参数是需要绑定的事件，第二个参数是触发事件后要执行的函数。而第三个参数默认值是false，表示在事件冒泡的阶段调用事件处理函数，如果参数为true，则表示在事件捕获阶段调用处理函数 DOM 事件流 事件捕获阶段 处于目标阶段 事件冒泡阶段 阻止事件冒泡 1event.stopPropagation()","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"Dom","slug":"Dom","permalink":"http://yoursite.com/tags/Dom/"}]},{"title":"如何配置github ssh连接","slug":"github-ssh-config","date":"2017-01-19T08:24:06.000Z","updated":"2017-01-19T08:28:43.629Z","comments":true,"path":"2017/01/19/github-ssh-config/","link":"","permalink":"http://yoursite.com/2017/01/19/github-ssh-config/","excerpt":"","text":"测试ssh连接是否正常1ssh -T git@coding.net 配置ssh连接1. 打开gitbash2. 生成public key用以下命令 邮箱换成自己的 1ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" 一路回车就行了 3. 找到生成的public key添加到github首先找到公钥文件id_rsa.pub，默认目录为C:/Users/[username]/.ssh，用文本编辑器打开并复制 然后参考这里 到这里就ok了可以找repo pull/push一下试一试了","categories":[],"tags":[]},{"title":"html input","slug":"html-input","date":"2017-01-19T08:12:32.000Z","updated":"2017-01-19T08:29:30.297Z","comments":true,"path":"2017/01/19/html-input/","link":"","permalink":"http://yoursite.com/2017/01/19/html-input/","excerpt":"","text":"在html5中 对于 1&lt;input type=\"file\"&gt; 可以用accept属性指定接收的文件类型。 Snytax1&lt;input accept=\"file_extension|audio/*|video/*|image/*|media_type\"&gt; To specify more than one value, separate the values with a comma (e.g. 1&lt;input accept=\"audio/*,video/*,image/*\" /&gt;","categories":[],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"Vue.js学习 - 创建第一个应用","slug":"vuejs-1","date":"2016-12-13T07:34:39.000Z","updated":"2016-12-13T13:05:40.340Z","comments":true,"path":"2016/12/13/vuejs-1/","link":"","permalink":"http://yoursite.com/2016/12/13/vuejs-1/","excerpt":"","text":"在github上创建一个项目在本地创建对应的reproinit git123456echo \"# test\" &gt;&gt; README.mdgit initgit add README.mdgit commit -m \"first commit\"git remote add origin https://github.com/BigYu/test.gitgit push -u origin master 我创建了两个branch，master和develop。如果是一个人写的小项目，其实没有必要。管他呢，就当假装follow gitflow的一点执念吧，嘻嘻。 init npm 加上-y选项，即全部填写默认值。如果将来需要修改，在文件里修改吧，什么都没写的时候干这些意义不大 准备好第三方依赖梳理一下我要用啥 vue.js ES2015(6?) &amp; babel webpack/webpack devserver sass 先暂时想到这些。以后想起来再加。 安装webpack12npm install --save-dev webpacknpm install webpack-dev-server -g dev server用于本地调试，所以没有加入到packages.json里 使用webpack dev server webpack.config.js 12345678910module.exports = &#123; entry: './src/index.js', output: &#123; path: './assets', filename: 'bundle.js' &#125;, devServer: &#123; port: 99 &#125;&#125;; src/index.js 1document.write('Hello vue!!! I am Yucong.'); bash commands 1webpack dev server 浏览器打开 http://localhost:99/webpack-dev-server/bundle 就能看到啦。自动刷新哦~ webpack bash command 1webpack 然后就看到bundle.js在assets目录下被创建了 再加入一个index.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=\"assets/bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 安装babel loader并调试 install 1npm install babel-loader babel-core babel-preset-es2015 --save-dev config 123456789101112module: &#123; loaders: [ &#123; test: /\\.js$/, exclude: /(node_modules|bower_components)/, loader: 'babel-loader', query: &#123; presets: ['es2015'] &#125; &#125; ]&#125; src/index.js 123import './test1';document.write('Hello vue!!! I am Yucong.'); src/test1.js 123import './test_module/test2';window.console.log('Hello'); src/test_module/test2.js 123456import test3 from './test3';const a = 2;alert(a);alert(test3.foo); src/test_module/test3.js 123export default &#123; foo: 'bar',&#125;; 这里还有一个问题，所有的import path都是相对路径，还不知道怎么做成绝对路径。。。 html loader1npm install html-loader --save-dev config 12 安装vue.js 写一个hello word1npm install vue --save index.js 12345678import Vue from 'vue';new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!', &#125;&#125;); The runtime-only build does not include the template compiler, and does not support the template option. You can only use the render option when using the runtime-only build, but it works with single-file components, because single-file components’ templates are pre-compiled into render functions during the build step. The runtime-only build is roughly 30% lighter-weight than the standalone build, weighing only 17.60kb min+gzip. 12345resolve: &#123; alias: &#123; 'vue$': 'vue/dist/vue.common.js' &#125;&#125; index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; &lt;script src=\"/bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"Frameworks","slug":"Frameworks","permalink":"http://yoursite.com/tags/Frameworks/"},{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/tags/Vue-js/"}]},{"title":"underscore源码阅读笔记（5）： defer","slug":"underscore-5","date":"2016-12-03T06:03:34.000Z","updated":"2016-12-03T06:37:09.894Z","comments":true,"path":"2016/12/03/underscore-5/","link":"","permalink":"http://yoursite.com/2016/12/03/underscore-5/","excerpt":"","text":"这周被邪恶的knockout狠狠的坑了一次，解决方法是用defer函数让ko的binding让调用栈结束之后进行。于是看了一下源码，了解一下defer的实现。 defer1_.defer = _.partial(_.delay, _, 1); partial123456789101112131415// Partially apply a function by creating a version that has had some of its// arguments pre-filled, without changing its dynamic `this` context. _ acts// as a placeholder, allowing any combination of arguments to be pre-filled._.partial = function(func) &#123; var boundArgs = slice.call(arguments, 1); var bound = function() &#123; var position = 0, length = boundArgs.length; var args = Array(length); for (var i = 0; i &lt; length; i++) &#123; args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i]; &#125; while (position &lt; arguments.length) args.push(arguments[position++]); return executeBound(func, bound, this, this, args); &#125;; return Partially apply a function by filling in any number of its arguments, without changing its dynamic this value. A close cousin of bind. You may pass _ in your list of arguments to specify an argument that should not be pre-filled, but left open to supply at call-time. 123456789var subtract = function(a, b) &#123; return b - a; &#125;;sub5 = _.partial(subtract, 5);sub5(20);=&gt; 15// Using a placeholdersubFrom20 = _.partial(subtract, _, 20);subFrom20(5);=&gt; 15 delay12345678// Delays a function for the given number of milliseconds, and then calls// it with the arguments supplied._.delay = function(func, wait) &#123; var args = slice.call(arguments, 2); return setTimeout(function()&#123; return func.apply(null, args); &#125;, wait);&#125;; setTimeout() will run asynchronously after finishing current execution block.","categories":[],"tags":[]},{"title":"Airbnb JavaScript Style Guide","slug":"code-convention","date":"2016-10-13T01:25:20.000Z","updated":"2016-10-17T07:53:31.754Z","comments":true,"path":"2016/10/13/code-convention/","link":"","permalink":"http://yoursite.com/2016/10/13/code-convention/","excerpt":"","text":"Note that both let and const are block-scoped. 1234567// const and let only exist in the blocks they are defined in.&#123; let a = 1; const b = 1;&#125;console.log(a); // ReferenceErrorconsole.log(b); // ReferenceError Use computed property names when creating objects with dynamic property names. 1234567891011121314151617function getKey(k) &#123; return `a key named $&#123;k&#125;`;&#125;// badconst obj = &#123; id: 5, name: 'San Francisco',&#125;;obj[getKey('enabled')] = true;// goodconst obj = &#123; id: 5, name: 'San Francisco', [getKey('enabled')]: true,&#125;; Do not call Object.prototype methods directly, such as hasOwnProperty, propertyIsEnumerable, and isPrototypeOf. Why? These methods may be shadowed by properties on the object in question - consider { hasOwnProperty: false } - or, the object may be a null object (Object.create(null)). 123456789101112// badconsole.log(object.hasOwnProperty(key));// goodconsole.log(Object.prototype.hasOwnProperty.call(object, key));// bestconst has = Object.prototype.hasOwnProperty; // cache the lookup once, in module scope./* or */const has = require('has');…console.log(has.call(object, key)); Use array spreads … to copy arrays. 1234567891011// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; Use object destructuring when accessing and using multiple properties of an object. jscs: Why? Destructuring saves you from creating temporary references for those properties. 123456789101112131415161718// badfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;// goodfunction getFullName(user) &#123; const &#123; firstName, lastName &#125; = user; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125; Use array destructuring. jscs: requireArrayDestructuring 12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; Strings that cause the line to go over 100 characters should not be written across multiple lines using string concatenation. 12345678910111213// badconst errorMessage = 'This is a super long error that was thrown because \\of Batman. When you stop to think about how Batman had anything to do \\with this, you would get nowhere \\fast.';// badconst errorMessage = 'This is a super long error that was thrown because ' + 'of Batman. When you stop to think about how Batman had anything to do ' + 'with this, you would get nowhere fast.';// goodconst errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.'; Do not unnecessarily escape characters in strings. eslint: no-useless-escape 123456// badconst foo = '\\'this\\' \\i\\s \\\"quoted\\\"';// goodconst foo = '\\'this\\' is \"quoted\"';const foo = `'this' is \"quoted\"`; Use named function expressions instead of function declarations. eslint: func-style jscs: 1234567891011// badconst foo = function () &#123;&#125;;// badfunction foo() &#123;&#125;// goodconst foo = function bar() &#123;&#125;; Prefer the use of the spread operator … to call variadic functions. eslint: prefer-spread 12345678910111213// badconst x = [1, 2, 3, 4, 5];console.log.apply(console, x);// goodconst x = [1, 2, 3, 4, 5];console.log(...x);// badnew (Function.prototype.bind.apply(Date, [null, 2016, 08, 05]));// goodnew Date(...[2016, 08, 05]);","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"有位孤独的裱糊匠","slug":"essay0","date":"2016-09-18T01:17:38.000Z","updated":"2016-09-26T01:22:17.741Z","comments":true,"path":"2016/09/18/essay0/","link":"","permalink":"http://yoursite.com/2016/09/18/essay0/","excerpt":"","text":"说起爱国，每个人都曾经在昏黄的灯光下，啃那些令人热血沸腾的一行行，一段段。也想过能振臂一呼“为中华之崛起而读书”。然而一百年过去了，我泱泱中华也早已不再是那个任人鱼肉的东亚病夫之邦，莘莘学子也早无救亡图存之忧，偶有几个不知是不是无病呻吟之辈锤着打鼓摇着“爱国主义教育”的旌旗，不得回应而啐骂小生们欺师忘祖谓之“毁掉的一代”。或者更需要的是在静夜的微风中细细琢磨一下，究竟何谓爱国，何谓国士，何谓英雄，那些年这块染血的土地上究竟是哪些人在扛着破败飘摇的民族前进。翁同龢之辈？他对中华的祸害，怕是远甚于巨贪和珅和清末一干赃官污吏。甲午年鲜血染红的黄海上，多少将士恨不能食其肉寝其皮，此之谓爱国贼。然而他忠心耿耿，满腹经纶，书法文章无不精通，若不是拖甲午战争后腿这个地实在不好洗，有人还想着树之为书生榜样让天下学子效仿吧。邓世昌邓公，此日漫挥天下泪，有公足壮海军威，岂不是大英雄。且不论多少凡夫俗子有邓公之志，邓公之才，邓公之威，只是不知道那些挥着热血红旗的人，可曾计算过要用多少大英雄的躯体，用多少致远舰的残骸，去填平专制农业国和宪政工业国之间的沟壑？哦，对了，百年来，举国歌颂纪念邓公，唯有一大汉奸卖国贼不以为然，认为此举不值得提倡，命令众官兵不要效仿。还修定了《海军惩劝章程》，担心将士们都学邓世昌，以轻生为壮。这个人把自己的姓名，签在了丧权辱国的马关条约和辛丑条约上。这个人不顾我中华上下五千年之文明，整天洋人长洋人短的鼓吹西洋奇技淫巧。这个人无视我中华地大物博，四万万众志成城的百姓，百万正义之师，却宣扬东洋的蕞尔小国多么强大，八国混杂的乌合之众装备精良，闭港闭关不敢一战。 一百年前的一个傍晚，地平线上矮矮的挂着帝国昏黄夕阳，狼狈的老佛爷光绪帝在西边餐风饮露惶惶如丧家之犬，豺狗般的八国联军在京师烧杀掳掠把东方的瑰宝装上强盗的货轮。还有那位孤独的老人领了老佛爷的懿旨正前往那龙潭虎穴之地。他在想什么？那部已经“不再公开播出”的电视剧中给出了这样一个有趣的场景：老者重重的拿皮鞭抽着陀螺，脸上孩童般的笑容，对着身边的丫鬟笑道：“又要去卖国，当汉奸，去卖国，去当汉奸，去卖国，去当汉奸。。。”或者谈判桌上，换上哪位爱国志士，直斥八国军匪虎狼之心，豺狼之态，让他们知道我们威武天朝正义之师不可战胜，就能让他们俯首称臣，省下那九万万两白银。又或者哪位大儒圣贤，能开化与鸟兽为伍的洋鬼子，使之知礼孝廉耻，明仁义道德，读四书五经，然后知道自己所作所为大悖伦常之道，能在孔孟圣贤庙前向我们赔礼道歉，然后受我天子教化。 签字的是不是李中堂，除了决定历史课本上黑锅的归属，怕是改变不了中华被列强蹂躏的命运；但从帝国主义嘴里抠回来辽东半岛，抠回来被彻底肢解的命运，恐怕那段岁月里在朝廷上粉墨登场过的，能做到的，也只有一个李鸿章吧。其实他应该蠢一点，无能一点，愚昧一点，或者能让已经瓤子里腐败的清廷，支离破碎的更早一点吧。哦，对了，少荃在日本，还吃了一颗价值一亿两白银的子弹呢。不知道现在的日本国民，是如何看待他们那位开枪的爱国青年的。哦，对了，就算历史课本上给黄海海战的结论是“北洋水师全军覆没”，别忘了日本人可打不沉定远镇远二舰。直到二战，这铁甲巨舰的路线还在发挥着威力。甚至几十年后二战太平洋和大西洋血染的海面上，还在证明着李中堂思路的正确。 “这是一个人对一个国家的战争”这是国外对甲午战争的一句评论。我们很难判断这句话是否成立——更可能的，这并非一个可以判断真伪的命题，儿仅仅是看到一个拥有“五千年文明”，“地大物博”，“不必与西洋互通有无”的大国支离破碎之后的一句感慨。历史的车轮在时光轴的这个横断面，刻下了一个大大的感叹号！四万万人中，难道只有这么一位可以大声疾呼“世界正经历三千年未有之巨变”，只有以变求变，才能有一线生机。至于那些跪倒在“祖宗之法”“圣贤教诲”前面泣血上奏的忠臣们，他们对中华的祸害，远甚于贪官污吏，远甚于流氓盗匪！时至今日，大家无不感叹鸿章大人生不逢时。但细细一想，也许所有真正能牵引时代前进的人，都要被打上一个“生不逢时”的标签吧：很难被他周围的人认可，不像李某落得个遗臭万年的下场，就算不错了。——这种人是为了未来制造的，为了那个还没有被世人，没有被当时掌握话语权的“主流”接受的那个未来。 所以，我们的历史书上，歌颂的是邓世昌。总不能歌颂翁老吧。他属于那个忠君报国的现在，属于那个清正廉明的现在。而李鸿章，属于那个机械轰鸣的未来。还有，那个帝国落日余晖折射下，民族无奈的未来。还有，他不停的要银子，花在破坏风水的洋务上，花在千里之外的海上。让京城里老佛爷的六十大寿，过得不那么开心啊。这岂是能鼓励和颂扬的？ 我们还是不要把历史当笑话读吧，也许今晚睡前可以话十分钟闭目想一下，我们每天茫茫碌碌，究竟是在修建那座美轮美奂的颐和园，还是打造一支也许回沉没的北洋水师。我们究竟在为老佛爷的六十大寿奋斗，还有没有隐隐为“未来”的波涛汹涌担忧。李鸿章是悲剧。让李鸿章出现的时代也是悲剧。土地上的亭台阁楼建起来了，时代的大屋子，去只能靠这位苍老的裱糊匠孤独的修补。那个风雨飘摇中踽踽独行的背影，是不是不应该那么熟悉？","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"underscore源码阅读笔记（4）： eq(cont.)","slug":"underscore-4","date":"2016-09-07T03:01:11.000Z","updated":"2016-09-07T03:18:06.358Z","comments":true,"path":"2016/09/07/underscore-4/","link":"","permalink":"http://yoursite.com/2016/09/07/underscore-4/","excerpt":"","text":"javascript判断变量类型的方法 javascript中 一切皆对象 1234567console.log(toString.call([123]));//[object Array]console.log(toString.call('123'));//[object String]console.log(toString.call(&#123;a: '123'&#125;));//[object Object]console.log(toString.call(/123/));//[object RegExp]console.log(toString.call(123));//[object Number]console.log(toString.call(undefined));//[object Undefined]console.log(toString.call(null));//[object Null] eq函数中不同类型的“相等”判断RegExp和string12345678// Strings, numbers, regular expressions, dates, and booleans are compared by value.case '[object RegExp]':// RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')case '[object String]': // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is // equivalent to `new String(\"5\")`. return '' + a === '' + b;· 以下“相等”均表示eq返回true 一个正则表达式 加上’’ 仍让与原来相等 “abc”和new String(‘abc’)是相等的 Number·123456case '[object Number]': // `NaN`s are equivalent, but non-reflexive. // Object(NaN) is equivalent to NaN if (+a !== +a) return +b !== +b; // An `egal` comparison is performed for other numeric values. return +a === 0 ? 1 / +a === 1 / b : +a === +b; js中 +NaN === +NaN 为false Object(NaN)和NaN相等 Date/Boolean123456case &apos;[object Date]&apos;:case &apos;[object Boolean]&apos;: // Coerce dates and booleans to numeric primitive values. Dates are compared by their // millisecond representations. Note that invalid dates with millisecond representations // of `NaN` are not equivalent. return +a === +b; To be continued","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"css中的定位","slug":"css-position","date":"2016-09-02T12:30:06.000Z","updated":"2016-09-26T01:22:12.914Z","comments":true,"path":"2016/09/02/css-position/","link":"","permalink":"http://yoursite.com/2016/09/02/css-position/","excerpt":"","text":"css的position属性定义元素的定位类型，Position属性有四个值：static、fixed、absolute和relative。主流的浏览器都是支持所有值的。 著名坑爹货：任何的版本的 Internet Explorer （包括 IE8）都不支持属性值 “inherit”。 static默认值 表示一个元素不会被positioned 仍然放在正常文档流中（“正常”是什么东西见上一篇关于浮动的） relative基本的表现和static一样 不同的是可以用top bottom left right属性来控制元素位置的偏移 fixed相对于视窗定位 就是说 即使页面滚动 元素的位置仍然不会改变 absuloteabsolute 与 fixed 的表现类似，除了它不是相对于视窗而是相对于最近的“positioned”祖先元素。如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它是相对于文档的 body 元素，并且它会随着页面滚动而移动。 一个“positioned”元素是指position 值不是 static 的元素。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"underscore源码阅读笔记（3）： eq","slug":"underscore-3","date":"2016-08-22T06:16:09.000Z","updated":"2016-08-22T06:16:15.202Z","comments":true,"path":"2016/08/22/underscore-3/","link":"","permalink":"http://yoursite.com/2016/08/22/underscore-3/","excerpt":"","text":"eq 函数源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// Internal recursive comparison function for `isEqual`.var eq = function(a, b, aStack, bStack) &#123; // Identical objects are equal. `0 === -0`, but they aren't identical. // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal). if (a === b) return a !== 0 || 1 / a === 1 / b; // A strict comparison is necessary because `null == undefined`. if (a == null || b == null) return a === b; // Unwrap any wrapped objects. if (a instanceof _) a = a._wrapped; if (b instanceof _) b = b._wrapped; // Compare `[[Class]]` names. var className = toString.call(a); if (className !== toString.call(b)) return false; switch (className) &#123; // Strings, numbers, regular expressions, dates, and booleans are compared by value. case '[object RegExp]': // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i') case '[object String]': // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is // equivalent to `new String(\"5\")`. return '' + a === '' + b; case '[object Number]': // `NaN`s are equivalent, but non-reflexive. // Object(NaN) is equivalent to NaN if (+a !== +a) return +b !== +b; // An `egal` comparison is performed for other numeric values. return +a === 0 ? 1 / +a === 1 / b : +a === +b; case '[object Date]': case '[object Boolean]': // Coerce dates and booleans to numeric primitive values. Dates are compared by their // millisecond representations. Note that invalid dates with millisecond representations // of `NaN` are not equivalent. return +a === +b; &#125; var areArrays = className === '[object Array]'; if (!areArrays) &#123; if (typeof a != 'object' || typeof b != 'object') return false; // Objects with different constructors are not equivalent, but `Object`s or `Array`s // from different frames are. var aCtor = a.constructor, bCtor = b.constructor; if (aCtor !== bCtor &amp;&amp; !(_.isFunction(aCtor) &amp;&amp; aCtor instanceof aCtor &amp;&amp; _.isFunction(bCtor) &amp;&amp; bCtor instanceof bCtor) &amp;&amp; ('constructor' in a &amp;&amp; 'constructor' in b)) &#123; return false; &#125; &#125; // Assume equality for cyclic structures. The algorithm for detecting cyclic // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`. // Initializing stack of traversed objects. // It's done here since we only need them for objects and arrays comparison. aStack = aStack || []; bStack = bStack || []; var length = aStack.length; while (length--) &#123; // Linear search. Performance is inversely proportional to the number of // unique nested structures. if (aStack[length] === a) return bStack[length] === b; &#125; // Add the first object to the stack of traversed objects. aStack.push(a); bStack.push(b); // Recursively compare objects and arrays. if (areArrays) &#123; // Compare array lengths to determine if a deep comparison is necessary. length = a.length; if (length !== b.length) return false; // Deep compare the contents, ignoring non-numeric properties. while (length--) &#123; if (!eq(a[length], b[length], aStack, bStack)) return false; &#125; &#125; else &#123; // Deep compare objects. var keys = _.keys(a), key; length = keys.length; // Ensure that both objects contain the same number of properties before comparing deep equality. if (_.keys(b).length !== length) return false; while (length--) &#123; // Deep compare each member key = keys[length]; if (!(_.has(b, key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) return false; &#125; &#125; // Remove the first object from the stack of traversed objects. aStack.pop(); bStack.pop(); return true;&#125;; 1234// Perform a deep comparison to check if two objects are equal._.isEqual = function(a, b) &#123; return eq(a, b);&#125;; 0 和 -0 的不同判断 123// Identical objects are equal. `0 === -0`, but they aren't identical.// See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).if (a === b) return a !== 0 || 1 / a === 1 / b; 在这里判断时，因为1/0会得到Infinite，而1/-0会得到-Infinite,而 Infinite === - Infinite会得到false，所以_.isEqual(0, -0)会得到false，尽管0 === -0会得到true。更加详细的说明作者在comments中提供了有详细解释的链接。 _.isEqual(null, undefined) 会得到false 12// A strict comparison is necessary because `null == undefined`.if (a == null || b == null) return a === b; 开始根据Classname来进行深度比较 123// Compare `[[Class]]` names.var className = toString.call(a);if (className !== toString.call(b)) return false; 这里会有一个很自然的疑问：下面那一行if是用来干嘛的？上面刚刚赋值，难道这里还会有以外吗？会！ 1[] !== [] // it is true! 之后就会根据不同的class（或者说type吧）进行不同的比较 未完待续","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"css中著名的坑爹货：浮动(float)和清浮动(clear)","slug":"css-float","date":"2016-08-18T11:29:59.000Z","updated":"2016-08-18T12:48:05.866Z","comments":true,"path":"2016/08/18/css-float/","link":"","permalink":"http://yoursite.com/2016/08/18/css-float/","excerpt":"","text":"css正常流布局div是html中最常见的元素，也是最典型的块级元素。块级元素会按照html中的顺序从上到下依次布局，每个占一行，也就是我们所说的“流”例子 而其他所有神奇的布局，归根结底都是解决一个问题： 如何在一行显示多个元素。 浮动浮动可以理解为（非准确定义！）：让块级元素脱离标准流，漂浮在另一个层次上 比如说上面的例子 我们让b浮动:b float left结果是，表示c的蓝色元素被挡住看不见了。因为b在浮动，不参与标准流布局，a,c,d仍然按照标准流布局，“漂浮”着的b挡住了c。并且这里的b是靠左排列，因为是左浮动，右浮动就是靠右排列：b float right让b和c一起左浮动 a和d会组成新的标准流， c会跟在b的后面，如果一行排不下，会被挤到下一行 ， d仍然在正常流中，被挡住。多个浮动元素的情况可以以此类推，就是一个跟着一个往一排里放，放不下了就放下一排。从左从右由浮动种类决定。这里可以出题啦：瀑布流，哇咔咔。这个写完了基本上面的就木有问题了。这里给个参考：https://github.com/duitang/waterfall 浮动元素和非浮动元素的排列 划重点啦 划重点啦 上面的b都是浮动的，a都是正常的。然后b都是在a的下面！！！重点，手动红色下划线： 假如某个div元素A是浮动的，如果A元素上一个元素也是浮动的，那么A元素会跟随在上一个元素的后边(如果一行放不下这两个元素，那么A元素会被挤到下一行)；如果A元素上一个元素是标准流中的元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐。 inline元素和浮动CSS display是指显示状态，inline表示内联，特点是紧贴着前一个内联元素，通常默认的内联元素有span,a,em,strong等。任何不是块级元素的可见元素都是内联元素.他和浮动的区别在于: inline元素是不能设置宽和高的。 打屁股的作业如下： 1&lt;span class=\"foo\"&gt;&lt;/span&gt;span&gt; 1234.foo &#123; width: 100px; height: 100px;&#125; 清浮动 语法： clear : none | left | right | both 取值： none : 默认值。允许两边都可以有浮动对象 left : 不允许左边有浮动对象 right : 不允许右边有浮动对象 both : 不允许有浮动对象 不清浮动清除d的左浮动 Bootstrap中的浮动向左快速浮动：pull-left向右快速浮动：pull-right清除浮动：clearfix","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"underscore源码阅读笔记（2）： reduce","slug":"underscore-2","date":"2016-08-17T02:01:07.000Z","updated":"2016-08-17T02:19:24.959Z","comments":true,"path":"2016/08/17/underscore-2/","link":"","permalink":"http://yoursite.com/2016/08/17/underscore-2/","excerpt":"","text":"reduce和reduceRight的实现： 123456// **Reduce** builds up a single result from a list of values, aka `inject`,// or `foldl`._.reduce = _.foldl = _.inject = createReduce(1);// The right-associative version of reduce, also known as `foldr`._.reduceRight = _.foldr = createReduce(-1); 核心：createReduce - 这是一个function decorator: 12345678910111213141516171819202122232425// Create a reducing function iterating left or right.function createReduce(dir) &#123; // Optimized iterator function as using arguments.length // in the main function will deoptimize the, see #1991. function iterator(obj, iteratee, memo, keys, index, length) &#123; for (; index &gt;= 0 &amp;&amp; index &lt; length; index += dir) &#123; var currentKey = keys ? keys[index] : index; memo = iteratee(memo, obj[currentKey], currentKey, obj); &#125; return memo; &#125; return function(obj, iteratee, memo, context) &#123; iteratee = optimizeCb(iteratee, context, 4); var keys = !isArrayLike(obj) &amp;&amp; _.keys(obj), length = (keys || obj).length, index = dir &gt; 0 ? 0 : length - 1; // Determine the initial value if none is provided. if (arguments.length &lt; 3) &#123; memo = obj[keys ? keys[index] : index]; index += dir; &#125; return iterator(obj, iteratee, memo, keys, index, length); &#125;;&#125; Optimized iterator function as using arguments.length in the main function will deoptimize the, see #1991. 换我这种人来写，肯定就是用arguments.length来取一下，然后开开心心的开始for循环了，嘿嘿嘿 195行到198行在干嘛？如果没有传初始值，则把第一个值作为初始值，同时移动一下初始迭代位置 191行同时支持数组和集合。可以借鉴：）","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"underscore源码阅读笔记（1）： optimizeCb","slug":"underscore-1","date":"2016-08-16T06:33:40.000Z","updated":"2016-08-16T07:04:06.316Z","comments":true,"path":"2016/08/16/underscore-1/","link":"","permalink":"http://yoursite.com/2016/08/16/underscore-1/","excerpt":"","text":"1234567891011121314151617181920212223// Internal function that returns an efficient (for current engines) version// of the passed-in callback, to be repeatedly applied in other Underscore// functions.var optimizeCb = function(func, context, argCount) &#123; if (context === void 0) return func; switch (argCount == null ? 3 : argCount) &#123; case 1: return function(value) &#123; return func.call(context, value); &#125;; case 2: return function(value, other) &#123; return func.call(context, value, other); &#125;; case 3: return function(value, index, collection) &#123; return func.call(context, value, index, collection); &#125;; case 4: return function(accumulator, value, index, collection) &#123; return func.call(context, accumulator, value, index, collection); &#125;; &#125; return function() &#123; return func.apply(context, arguments); &#125;;&#125;; 这里主要做了两个地方的优化可以注意： 避免使用arguments，尽量使用指定参数 尽量用call而不是apply","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"jquery 为动态添加的元素绑定事件","slug":"jQuery-Delegate-events","date":"2016-08-01T07:45:46.000Z","updated":"2016-08-01T07:46:52.433Z","comments":true,"path":"2016/08/01/jQuery-Delegate-events/","link":"","permalink":"http://yoursite.com/2016/08/01/jQuery-Delegate-events/","excerpt":"","text":"live函数已经被废弃了！！ 如果直接写click函数的话，只能把事件绑定在已经存在的元素上，不能绑定在动态添加的元素上 尝试过重新调用，结果是重复触发。。。 ###可以用delegate来实现 1.delegate( selector, eventType, handler ) 例如： 1234$('someUlSelector').delegate('someLiSelector', 'click', function() &#123; //codes... //$(this) for the current jquery instance of the element&#125;);","categories":[],"tags":[{"name":"Frameworks","slug":"Frameworks","permalink":"http://yoursite.com/tags/Frameworks/"}]},{"title":"What I learn after first glance on ReactJs","slug":"React-notes","date":"2016-08-01T04:47:47.000Z","updated":"2016-08-01T05:40:10.891Z","comments":true,"path":"2016/08/01/React-notes/","link":"","permalink":"http://yoursite.com/2016/08/01/React-notes/","excerpt":"","text":"就不再这里罗列各种关于React的新特性或者feature了，意义不大，而且我也是初学者。之前我个人也一直很喜欢Facebook的东西——小巧，简单，清晰，还有他们漂亮的文档实在是吸引人去看。 f(Status) = UI 这个公式可以概括React作为view层面的framework最精髓的地方。你的code可以根据逻辑操作status。status的变化反映在UI上的变化大部分工作室React帮我们做的，开发者只需要很少的精力去编写，或者说是配置status和UI之间的映射关系。UI是复杂的，我们现在处理五花八门的dom结构就已经十分头痛了，再加上种类越来越多的富文本元素，再加上，再加上越来越复杂的动态交互，使得现在UI的开发成本越来越高，代码越来越复杂，而且runtime的维护成本也越来越高。包括缓存在内的问题也越来越棘手。Status是简单的，清晰的（我觉得清晰比简单更加能吸引我。当然，让事情变简单可以让事情变清晰）。Status就是数据结构，对于UI来说，并不会十分复杂和庞大，一般只需要一些简单的array和object。处理他们是程序员们最熟悉的事情，而且可以想象代码可以像数据结构课本上那么清晰明了。另外，做UI的Cache和Delta的代价显然十分高昂，但是换成这么一堆初学者都能看懂的array啊object啊就完全不是问题了，这也是React给出来的魔术般的解决缓存和Performance的策略：页面的render是基于status update的delta来的。 单向数据流 我们之前遇到的各种前端框架显然不满足 1f(Status) = UI 通常来说，应该是 1f(Status, 用户交互，推送信息，其他UI联动变化，……) = UI 那么React必然要做的事情就是实现一个 1g(上面其他因素) = status 这就是需要单向数据流的原因。我个人的体会，因为可能已经习惯了诸如knockout、angularjs等成熟的框架提供的各种完善的two-way data-binding的机制，第一眼很难接受React的one-way data flow，而且写一些很小的component的时候（比如hello world之类的），会发现很简单的事情反而需要我们花一些额外的精力。比如一个最简单的input框，如果用ko，只需要把他和vm上一个observable绑定就好了，在ng中也是很简单的ng-model=xxx，但是突然React告诉你，不行，你要绕一圈，你的输入只能作用于status的update，绕一圈才能回到UI的变化，当然不习惯。Facebook的工程师们肯定不是吃饱了撑的才这样设计。我们可以想象一些稍微复杂的逻辑——比如，如果这个input框需要把用户的输入全部转成大写字母，或者拒绝掉一些非法字符。当然，现在的框架已经足够优秀，我们可以pass in各种custom filter。问题就在于当这些需求一个一个堆砌起来，逻辑就会逐渐变得混乱，filter，suscription，events等等聚集在一起，代码的可读性会严重降低且难以维护。当UI中的元素越来越多，业务越来越复杂，这些不便利之处会指数级爆炸。而单向的数据流就不存在这些问题了，flux中有一个很好的Dispature和Store的概念，就像现代物流的集散分拣中心一样的（此处谢绝抬杠），一件快递的时候看起来不必要，但是成千上万的数据涌来，他依然能把所有的东西处理得井井有条，所有的东西就像阅兵式上的方阵，清晰有条理。我们会被从filter，suscription，events中被拯救出来，只有两样简单的事情：status，UI。","categories":[],"tags":[{"name":"Frameworks","slug":"Frameworks","permalink":"http://yoursite.com/tags/Frameworks/"}],"keywords":["React Js","One-way data-binding","UI"]},{"title":"Hello World","slug":"hello-world","date":"2016-07-31T10:19:21.655Z","updated":"2016-07-31T10:19:21.662Z","comments":true,"path":"2016/07/31/hello-world/","link":"","permalink":"http://yoursite.com/2016/07/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}