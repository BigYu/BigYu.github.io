{"meta":{"title":"Yucong's Blog","subtitle":null,"description":"No matter where we are going, it starts from where we are","author":"体力劳动者","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Data binding: hijack and dependencies collection","slug":"deps-collection","date":"2017-10-18T02:22:55.000Z","updated":"2017-10-18T07:34:10.209Z","comments":true,"path":"2017/10/18/deps-collection/","link":"","permalink":"http://yoursite.com/2017/10/18/deps-collection/","excerpt":"","text":"见过的前端js框架，data-binding的实现方案大致有三种： 直接把数据的暴露成function,如knockout dirty check, 如angular 劫持getter,setter + 依赖收集,如vue 写下第三种： Vue 源码 我们的demo code是这样的： 1234form input(type=&quot;text&quot;, v-bind=&quot;count&quot;) button(type=&quot;button&quot;, v-click=&quot;increment&quot;) incrementdiv(v-bind=&quot;count&quot;) 123456789101112131415161718import &#123; Observable, Watcher &#125; from '@bingads-webui/simple-observable';const person = new Observable(&#123; firstName: 'Michael', lastName: 'Jordan',&#125;);new Watcher(person, 'fullName', () =&gt; &#123; return `$&#123;person.firstName&#125; $&#123;person.lastName&#125;`;&#125;, (val) =&gt; &#123; console.log(`The full name is $&#123;val&#125;`);&#125;);console.log(person.fullName);person.lastName = 'Jackson';window.person = person; 带dom操作的: 123456789101112131415import &#123; App &#125; from '@bingads-webui/simple-observable';import template from './index.pug';new App(&#123; el: document.body, template, data: &#123; count: 3, &#125;, method: &#123; increment: function() &#123; this.data.count++; &#125; &#125;,&#125;); Observable在属性被读写的时候主动通知：1234567891011121314151617const person = &#123;&#125;;let firstName = 'Michael';Object.defineProperty(person, 'firstName', &#123; get() &#123; console.log('Reading person.firstName'); return 'Michael'; &#125;, set(val) &#123; console.log(`Setting person.firstName $&#123;val&#125;`); firstName = val; &#125;&#125;); 我们可以定义最基本的observable类和defineReactive方法： 12345678910111213141516171819202122232425function defineReactive(obj, key, val) &#123; Object.defineProperty(obj, key, &#123; get() &#123; // todo return val; &#125;, set(newVal) &#123; // todo val = newVal; &#125;, &#125;);&#125;function obervable(obj) &#123; const keys = Object.keys(obj); keys.forEach((key) =&gt; &#123; defineReactive(obj, key, obj[key]); &#125;); return obj;&#125; Refactor一下，写成class 12345678910111213141516171819202122232425262728293031class Observable &#123; constructor(obj) &#123; return this.walk(obj); &#125; walk(obj) &#123; const keys = Object.keys(obj); keys.forEach((key) =&gt; &#123; this.defineReactive(obj, key, obj[key]); &#125;); return obj; &#125; defineReactive(obj, key, val) &#123; Object.defineProperty(obj, key, &#123; get() &#123; // todo return val; &#125;, set(newVal) &#123; // todo val = newVal; &#125;, &#125;); &#125;&#125; Watcher现在来实现demo中的这个部分： 123new Watcher(person, 'fullName', () =&gt; &#123; return `$&#123;person.firstName&#125; $&#123;person.lastName&#125;`;&#125;); (有没有觉得和dirty check里面的$$watchers很像。。。后面还有更像的) watcher属性无法被赋值 watcher的值由第三个参数决定 123456789101112function watcher(obj, key, getVal) &#123; Object.defineProperty(obj, key, &#123; get() &#123; const val = getVal(); return val; &#125;, set() &#123; throw new Error('Cannot set values of wathers.'); &#125; &#125;)&#125; 改写成watcher类并加入listener 123456789101112131415161718192021222324252627282930313233class Watcher &#123; constructor(obj, key, cb， onComputedUpdate) &#123; this.obj = obj; this.key = key; this.cb = cb; this.onComputedUpdate = onComputedUpdate; return this.defineComputed(); &#125; defineComputed() &#123; const self = this; const onDepUpdated = () =&gt; &#123; const val = self.cb(); this.onComputedUpdate(val); &#125;; Object.defineProperty(this.obj, this.key, &#123; get() &#123; const val = self.cb(); this.onComputedUpdate(val); return val; &#125;, set() &#123; throw new Error('Cannot set values of wathers.'); &#125;, &#125;); &#125;&#125; 这样observable和watcher就可以一起工作了： 123const person = new Observable(&#123; firstName: 'Michael', lastName: 'Jordan' &#125;);new Watcher(person, 'fullName', () =&gt; `$&#123;person.firstName&#125; $&#123;person.lastName&#125;`, (val) =&gt; &#123; console.log(`new value $&#123;val&#125;`) &#125;); Dependencies collection这样有一个问题：我们是主动去取fullName的值的时候，它才会被计算。而我们期望的行为，是firstName或者lastName被修改的时候，主动通知fullName，并更新,触发onComputedUpdate。可以设计这样一个dependency collector, 来收集所有的dependencies. 具体一点就是,让一个observable知道有哪些watcher依赖它,并且在自己被赋值的时候通知watcher. 注意到watcher的getter被call到的时候,它依赖哪些observable,就会call到这些observable,可以用这个时机来告诉observable,这个watcher依赖你了.然后在call到setter时,就可以把dependencies拿出来通知: 简单版本,拿一个全局变量存dependencies做依赖收集器 123const Dep = &#123; target: null,&#125;; 在watcher中: 12345678910111213141516171819defineComputed() &#123; const self = this; Object.defineProperty(this.obj, this.key, &#123; get() &#123; Dep.target = () =&gt; &#123; const val = self.cb(); this.onComputedUpdate(val); &#125; const val = self.cb(); return val; &#125;, set() &#123; throw new Error('Cannot set values of wathers.'); &#125;, &#125;);&#125; 在observable中 123456789101112131415defineReactive(obj, key, val) &#123; const deps = []; Object.defineProperty(obj, key, &#123; get() &#123; deps.push(Dep.target); return val; &#125;, set(newVal) &#123; val = newVal; deps.forEach(dep =&gt; dep()); &#125;, &#125;); 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147import _ from 'underscore';class Dep &#123; constructor() &#123; this.deps = []; &#125; depend() &#123; if (Dep.target &amp;&amp; this.deps.indexOf(Dep.target) === -1) &#123; this.deps.push(Dep.target); &#125; &#125; notify() &#123; this.deps.forEach((dep) =&gt; &#123; dep(); &#125;); &#125;&#125;Dep.target = null;export class Observable &#123; constructor(obj) &#123; return this.walk(obj); &#125; walk(obj) &#123; const keys = Object.keys(obj); keys.forEach((key) =&gt; &#123; this.defineReactive(obj, key, obj[key]); &#125;); return obj; &#125; defineReactive(obj, key, val) &#123; const dep = new Dep(); Object.defineProperty(obj, key, &#123; get() &#123; dep.depend(); return val; &#125;, set(newVal) &#123; val = newVal; dep.notify(); &#125;, &#125;); &#125;&#125;export class Watcher &#123; constructor(obj, key, cb, onComputedUpdate) &#123; this.obj = obj; this.key = key; this.cb = cb; this.onComputedUpdate = onComputedUpdate; return this.defineComputed(); &#125; defineComputed() &#123; const self = this; const onDepUpdated = () =&gt; &#123; const val = self.cb(); this.onComputedUpdate(val); &#125;; Object.defineProperty(this.obj, this.key, &#123; get() &#123; Dep.target = onDepUpdated; const val = self.cb(); Dep.target = null; return val; &#125;, set() &#123; throw new Error('Cannot assign value computed!'); &#125;, &#125;); &#125;&#125;export class App &#123; constructor(&#123; el, template, data, method &#125;) &#123; this.el = el; this.template = template; this.data = new Observable(data); this.method = method; this.render(); this.applyBindings(); &#125; applyBindings() &#123; const bindList = this.el.querySelectorAll('[v-bind]'); _.each(bindList, (bind) =&gt; &#123; const bindKey = bind.getAttribute('v-bind'); if (bind.tagName === 'INPUT') &#123; // bind.value = this.data[bindKey]; new Watcher(this.data, `$$&#123;bindKey&#125;Value`, () =&gt; &#123; return this.data[bindKey]; &#125;, (newVal) =&gt; &#123; bind.value = newVal; &#125;); bind.value = this.data[`$$&#123;bindKey&#125;Value`]; bind.addEventListener('input', (e) =&gt; &#123; this.data[bindKey] = e.target.value; &#125;); &#125; else &#123; new Watcher(this.data, `$$&#123;bindKey&#125;InnerHtml`, () =&gt; &#123; return this.data[bindKey]; &#125;, (newVal) =&gt; &#123; bind.innerHTML = newVal; &#125;); bind.innerHTML = this.data[`$$&#123;bindKey&#125;InnerHtml`]; &#125; &#125;); const clickList = this.el.querySelectorAll('[v-click]'); _.each(clickList, (click) =&gt; &#123; const clickKey = click.getAttribute('v-click'); const clickFunc = this.method[clickKey]; click.onclick = clickFunc.bind(this); &#125;); &#125; render() &#123; this.el.innerHTML = this.template(); &#125;&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"framework","slug":"framework","permalink":"http://yoursite.com/tags/framework/"},{"name":"data binding","slug":"data-binding","permalink":"http://yoursite.com/tags/data-binding/"}]},{"title":"data-binding: dirty check","slug":"dirty-check","date":"2017-10-11T07:31:04.000Z","updated":"2017-10-17T11:03:02.022Z","comments":true,"path":"2017/10/11/dirty-check/","link":"","permalink":"http://yoursite.com/2017/10/11/dirty-check/","excerpt":"","text":"见过的前端js框架，data-binding的实现方案大致有三种： 直接把数据的暴露成function,如knockout dirty check, 如angular 劫持getter,setter + 依赖收集,如vue 自己实现了一个非常简化的dirty-check $$watchersscope是angular中最重要的一个概念，这里不再重复。用dirty check来实现data binding,scope中的$$watchers起到了核心的作用。$$watchers是一个数组，用于存放scope下所有的数据。每个数据有以下几个字段： name: 变量名，就是$scope.someName中的someName last: 变量上一次的值，这是一个值。 newVal: 获取新值的函数，这是个函数。 listener: 监听的回掉函数。 $watch将一个新的成员加入$$watchers 12345678$watch(name, exp, listener = function () &#123;&#125;) &#123; this.$$watchers.push(&#123; name, last: '', newVal: exp, listener, &#125;);&#125; 有了$watch方法，我们就可以把scope中的所有值都加入$$watchers: 12345for (const key in $scope) &#123; if (key != '$$watchers' &amp;&amp; !_.isFunction($scope[key])) &#123; $scope.$watch(key, () =&gt; $scope[key]); &#125;&#125; $digest$digest的作用，就是遍历$$watchers里所有的值，比较新值和旧值，调用listener，并把新值赋值给last,直到所有的新值旧值都相等。 123456789101112131415161718$digest() &#123; let dirty = true; while (dirty) &#123; dirty = false; _.each(this.$$watchers, (watcher) =&gt; &#123; const newVal = watcher.newVal(); const oldVal = watcher.last; if (newVal !== oldVal &amp;&amp; !_.isNaN(newVal) &amp;&amp; !_.isNaN(oldVal)) &#123; dirty = true; watcher.listener(oldVal, newVal); watcher.last = newVal; &#125; &#125;); &#125;&#125; 再加入更新dom元素的逻辑，就变成了 12345678910111213141516171819202122232425262728293031$digest() &#123; const bindList = document.querySelectorAll('[ng-bind]'); let dirty = true; while (dirty) &#123; dirty = false; _.each(this.$$watchers, (watcher) =&gt; &#123; const newVal = watcher.newVal(); const oldVal = watcher.last; if (newVal !== oldVal &amp;&amp; !_.isNaN(newVal) &amp;&amp; !_.isNaN(oldVal)) &#123; dirty = true; watcher.listener(oldVal, newVal); watcher.last = newVal; _.each(bindList, (bind) =&gt; &#123; const modelName = bind.getAttribute('ng-bind'); if (modelName === watcher.name) &#123; if (bind.tagName === 'INPUT') &#123; bind.value = this[modelName]; &#125; else &#123; bind.innerHTML = this[modelName]; &#125; &#125; &#125;); &#125; &#125;); &#125; &#125; 绑定到dom剩余的工作就是把一些dom事件绑定一下，这里简单的绑定一下click button和inputbox的change 1234567891011121314151617const clickBindList = document.querySelectorAll('[ng-click]');_.each(clickBindList, (clickBind) =&gt; &#123; clickBind.onclick = () =&gt; &#123; $scope[clickBind.getAttribute('ng-click')](); $scope.$digest(); &#125;;&#125;);const inputList = document.querySelectorAll('input[ng-bind]');_.each(inputList, (input) =&gt; &#123; input.addEventListener('input', () =&gt; &#123; $scope[input.getAttribute('ng-bind')] = input.value; $scope.$digest(); &#125;);&#125;); 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import _ from 'underscore';class Scope &#123; constructor() &#123; this.$$watchers = []; &#125; $watch(name, exp, listener = function () &#123;&#125;) &#123; this.$$watchers.push(&#123; name, last: '', newVal: exp, listener, &#125;); &#125; $digest() &#123; const bindList = document.querySelectorAll('[ng-bind]'); let dirty = true; while (dirty) &#123; dirty = false; _.each(this.$$watchers, (watcher) =&gt; &#123; const newVal = watcher.newVal(); const oldVal = watcher.last; if (newVal !== oldVal &amp;&amp; !_.isNaN(newVal) &amp;&amp; !_.isNaN(oldVal)) &#123; dirty = true; watcher.listener(oldVal, newVal); watcher.last = newVal; _.each(bindList, (bind) =&gt; &#123; const modelName = bind.getAttribute('ng-bind'); if (modelName === watcher.name) &#123; if (bind.tagName === 'INPUT') &#123; bind.value = this[modelName]; &#125; else &#123; bind.innerHTML = this[modelName]; &#125; &#125; &#125;); &#125; &#125;); &#125; &#125;&#125;export function ngController(controller) &#123; const $scope = new Scope(); controller($scope); const clickBindList = document.querySelectorAll('[ng-click]'); _.each(clickBindList, (clickBind) =&gt; &#123; clickBind.onclick = () =&gt; &#123; $scope[clickBind.getAttribute('ng-click')](); $scope.$digest(); &#125;; &#125;); const inputList = document.querySelectorAll('input[ng-bind]'); _.each(inputList, (input) =&gt; &#123; input.addEventListener('input', () =&gt; &#123; $scope[input.getAttribute('ng-bind')] = input.value; $scope.$digest(); &#125;); &#125;); for (const key in $scope) &#123; if (key != '$$watchers' &amp;&amp; !_.isFunction($scope[key])) &#123; $scope.$watch(key, () =&gt; $scope[key]); &#125; &#125; $scope.$digest();&#125;; Demo123456ngController(($scope) =&gt; &#123; $scope.count = 0; $scope.increment = () =&gt; &#123; $scope.count++; &#125;;&#125;);","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"framework","slug":"framework","permalink":"http://yoursite.com/tags/framework/"},{"name":"data binding","slug":"data-binding","permalink":"http://yoursite.com/tags/data-binding/"}]},{"title":"Object.defineProperty","slug":"defineObject-and-observable-watch","date":"2017-09-27T12:26:26.000Z","updated":"2017-09-27T12:43:16.062Z","comments":true,"path":"2017/09/27/defineObject-and-observable-watch/","link":"","permalink":"http://yoursite.com/2017/09/27/defineObject-and-observable-watch/","excerpt":"","text":"Object.defineProperty在js中我们用可以用这样几种方法定义属性： 1foo.bar = 'abc'; 1foo['bar'] = 'abc'; 123Object.defineProperty(foo, 'bar', &#123; value: 'abc',&#125;); defineProperty(MDN链接)这种方法，最麻烦，最强大. 语法1Object.defineProperty(obj, prop, descriptor) 参数 obj: 需要被操作的目标对象 prop: 目标对象需要定义或修改的属性的名称 descriptor: 将被定义或修改的属性的描述符。 返回值被传递给函数的对象 descriptor之前列出来的比较简单的两种写法，是通过赋值来创建并显示在属性枚举中（for...in或Object.keys），可以被修改，也可以被删除。使用definePropery,可以控制这些： configurable: 这个值为true时，descriptor才可以被修改，同时这个property也能从obj上被删除。默认为false。 enumerable: 这个值为true时，才可以出现在for...in或者Object.keys中 value: property的值。默认undefined。 writable: 这个值为true时，propery才能被赋值运算符改变。默认false。 get/set: 就跟其他的getter/setter差不多，包括es6的getter/setter","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"Backbone model- on vs listenTo","slug":"on-vs-listenTo","date":"2017-07-10T09:06:50.000Z","updated":"2017-07-10T09:33:21.001Z","comments":true,"path":"2017/07/10/on-vs-listenTo/","link":"","permalink":"http://yoursite.com/2017/07/10/on-vs-listenTo/","excerpt":"","text":"发现好久没有写blog了 要捡回来这个好习惯：） 今天遇到了一个bug，给一个全局的（不要吐槽,legacy code留下来的全局的东西没那么好消灭干净）添加了一个事件的callback，大致代码是这样 123aGlobalModel.on('a-event', () =&gt; &#123; someView.doSomething();&#125;); 原因是，someView被remove的时候，忘了call gGlabal.off. Ok, 加上off逻辑当然不难，但是： 直接call off会清理掉所有的handler。这坑爹货是全局的。。。。 可以指定off哪一个callback，所以这个callback会被传来传去。。比方说有很多处会remove的情况。on 并不是在someView里定义的。 事实上，listenTo是一个更好的选择。 123someView.listenTo(aGlobalModel, 'a-event', () =&gt; &#123; // ...code&#125;) 当someView的remove被call到的时候 会自动的执行stopListening. 看一下Backbone源码 on 12345678910111213141516171819// Bind an event to a `callback` function. Passing `\"all\"` will bind// the callback to all events fired.Events.on = function(name, callback, context) &#123; this._events = eventsApi(onApi, this._events || &#123;&#125;, name, callback, &#123; context: context, ctx: this, listening: _listening &#125;); if (_listening) &#123; var listeners = this._listeners || (this._listeners = &#123;&#125;); listeners[_listening.id] = _listening; // Allow the listening to use a counter, instead of tracking // callbacks for library interop _listening.interop = false; &#125; return this;&#125;; listenTo 1234567891011121314151617181920212223242526// Inversion-of-control versions of `on`. Tell *this* object to listen to// an event in another object... keeping track of what it's listening to// for easier unbinding later.Events.listenTo = function(obj, name, callback) &#123; if (!obj) return this; var id = obj._listenId || (obj._listenId = _.uniqueId('l')); var listeningTo = this._listeningTo || (this._listeningTo = &#123;&#125;); var listening = _listening = listeningTo[id]; // This object is not listening to any other events on `obj` yet. // Setup the necessary references to track the listening callbacks. if (!listening) &#123; this._listenId || (this._listenId = _.uniqueId('l')); listening = _listening = listeningTo[id] = new Listening(this, obj); &#125; // Bind callbacks on obj. var error = tryCatchOn(obj, name, callback, this); _listening = void 0; if (error) throw error; // If the target obj is not Backbone.Events, track events manually. if (listening.interop) listening.on(name, callback); return this;&#125;; 上述代码中用到的eventsApi,是标准的事件，回调迭代器： 12345678910111213141516171819202122// Iterates over the standard `event, callback` (as well as the fancy multiple// space-separated events `\"change blur\", callback` and jQuery-style event// maps `&#123;event: callback&#125;`).var eventsApi = function(iteratee, events, name, callback, opts) &#123; var i = 0, names; if (name &amp;&amp; typeof name === 'object') &#123; // Handle event maps. if (callback !== void 0 &amp;&amp; 'context' in opts &amp;&amp; opts.context === void 0) opts.context = callback; for (names = _.keys(name); i &lt; names.length ; i++) &#123; events = eventsApi(iteratee, events, names[i], name[names[i]], opts); &#125; &#125; else if (name &amp;&amp; eventSplitter.test(name)) &#123; // Handle space-separated event names by delegating them individually. for (names = name.split(eventSplitter); i &lt; names.length; i++) &#123; events = iteratee(events, names[i], callback, opts); &#125; &#125; else &#123; // Finally, standard events. events = iteratee(events, name, callback, opts); &#125; return events;&#125;;","categories":[],"tags":[{"name":"Framework","slug":"Framework","permalink":"http://yoursite.com/tags/Framework/"},{"name":"Backbone","slug":"Backbone","permalink":"http://yoursite.com/tags/Backbone/"},{"name":"Events","slug":"Events","permalink":"http://yoursite.com/tags/Events/"}]},{"title":"es6-generator","slug":"es6-generator","date":"2017-03-24T08:54:15.000Z","updated":"2017-03-31T02:26:32.766Z","comments":true,"path":"2017/03/24/es6-generator/","link":"","permalink":"http://yoursite.com/2017/03/24/es6-generator/","excerpt":"","text":"看babel官网上提供的例子 123456789101112131415161718var fibonacci = &#123; [Symbol.iterator]: function*() &#123; var pre = 0, cur = 1; for (;;) &#123; var temp = pre; pre = cur; cur += temp; yield cur; &#125; &#125;&#125;for (var n of fibonacci) &#123; // truncate the sequence at 1000 if (n &gt; 1000) break; console.log(n);&#125; 在for…of…循环中，会调用迭代器对象的迭代器方法。之前那篇迭代器有提到过，但是这里的function*和普通的函数function不一样。如果是普通的函数，不管什么时候执行，得到的结果总是一样的（不考虑全局变量之类的干扰），或者说，和上一次无关。","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"ES6(ES2015)","slug":"ES6-ES2015","permalink":"http://yoursite.com/tags/ES6-ES2015/"}]},{"title":"Javascript中的稀疏数组 sparse arrays vs. 密集数组 dense arrays","slug":"dense-arrays","date":"2017-03-21T06:49:41.000Z","updated":"2017-03-23T06:09:27.267Z","comments":true,"path":"2017/03/21/dense-arrays/","link":"","permalink":"http://yoursite.com/2017/03/21/dense-arrays/","excerpt":"","text":"大多数情况下，javascript中的数组是稀疏数组（其实就是k-v pairs），也就是说a[0], a[100]存在，但是a[1]到a[99]可能都不存在。 不存在，不是说存在但是是undefined,就是真正的不存在:如果用foreach访问并console.log，会发现根本没有这么一项，而不是输出一个undefined 实际上,JavaScript并没有常规的数组,所有的数组其实就是个对象,只不过会自动管理一些”数字”属性和length属性罢了.说的更直接一点,JavaScript中的数组根本没有索引,因为索引应该是数字,而JavaScript中数组的索引其实是字符串.arr[1]其实就是arr[“1”],给arr[“1000”] = 1,arr.length也会自动变为1001.这些表现的根本原因就是,JavaScript中的对象就是字符串到任意值的键值对.注意键只能是字符串 sparse arrays 得到一个稀疏数组 1var sparseArr1 = new Array(3); 1234var sparseArr2 = [];sparseArr2[0] = 1;sparseArr2[100] = 100; 遍历稀疏数组，所有的“空隙”会被跳过123456var sparseArr2 = [];sparseArr2[0] = 1;sparseArr2[100] = 100;sparseArr2.forEach(function(index, val) &#123; console.log(index); console.log(val) &#125;) // output: 1 0 100 100 dense arrays 得到一个密集数组 1Array(undefined, undefined, undefined) 1var denseArr1 = Array.apply(null, Array(3))； 1var denseArr2 = Array.apply(null, Array(3)).map(Function.prototype.call.bind(Number))","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"ES6 - destructuring 整体析构赋值","slug":"destructuring","date":"2017-03-20T13:18:57.000Z","updated":"2017-03-24T08:56:38.188Z","comments":true,"path":"2017/03/20/destructuring/","link":"","permalink":"http://yoursite.com/2017/03/20/destructuring/","excerpt":"","text":"这个汉化——“ 整体析构赋值”——是抄的，我真的翻译不来。。。 Array// list matching 1234const [a, ,b] = [1,2,3];a === 1;b === 3; Object12345const obj = &#123; a: 1, b: 2, c: 3&#125;;const &#123;a, c&#125; = obj;a === 1;c === 3; function parameters Can be used in parameter position 1234function g(&#123;name: x&#125;) &#123; console.log(x);&#125;g(&#123;name: 5&#125;) Work with default args 1234function r(&#123;x, y, w = 10, h = 10&#125;) &#123; return x + y + w + h;&#125;r(&#123;x:1, y:2&#125;) === 23","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"ES6(ES2015)","slug":"ES6-ES2015","permalink":"http://yoursite.com/tags/ES6-ES2015/"}]},{"title":"iterators & for...of... es6迭代器","slug":"iterators","date":"2017-03-16T14:01:56.000Z","updated":"2017-03-20T13:21:47.098Z","comments":true,"path":"2017/03/16/iterators/","link":"","permalink":"http://yoursite.com/2017/03/16/iterators/","excerpt":"","text":"用for…in…一定要小心！！12345var myArray = [1, 2, 3, 4, 5];for (var index in myArray) &#123; // never do this!! console.log(myArray[index]);&#125; index不是number而是string，说不定就让自己掉进 ‘2’ + 1 == ‘21’ 这样的bug里了 for-in还会作用于自定义属性（myArray.name这种） 有些时候顺序是随机的 简而言之，for-in是为普通对象设计的，你可以遍历得到字符串类型的键，因此不适用于数组遍历 .forEach的局限123myArray.forEach(funciton(val) &#123; console.log(val);&#125;) 不能使用break语句中断循环，也不能使用return语句返回到外层函数 for…of in es6 正确响应break, continue 避免for…in的缺点 除了Array, 还可以遍历String, map, set 迭代器对象for-of循环语句通过方法调用来遍历各种集合。数组、Maps对象、Sets对象以及其它在我们讨论的对象有一个共同点，它们都有一个迭代器方法。 你可以给任意类型的对象添加迭代器方法。 当你为对象添加myObject.toString()方法后，就可以将对象转化为字符串，同样地，当你向任意对象添加myObjectSymbol.iterator方法，就可以遍历这个对象了 for-of循环首先调用集合的Symbol.iterator方法，紧接着返回一个新的迭代器对象。迭代器对象可以是任意具有.next()方法的对象；for-of循环将重复调用这个方法，每次循环调用一次","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"event flow","slug":"event-flow","date":"2017-03-15T02:23:36.000Z","updated":"2017-03-20T08:27:02.220Z","comments":true,"path":"2017/03/15/event-flow/","link":"","permalink":"http://yoursite.com/2017/03/15/event-flow/","excerpt":"","text":"流 Flow - 事件流 event flow简单来说 流就是具有方向的数据事件流所描述的就是从页面中接受事件的顺序。 事件冒泡事件冒泡即事件开始时，由最具体的元素接收（也就是事件发生所在的节点），然后逐级传播到较为不具体的节点 事件捕获当某个事件发生时，父元素应该更早接收到事件，具体元素则最后接收到事件 addEventListener1element.addEventListener(event, function, useCapture) 第一个参数是需要绑定的事件，第二个参数是触发事件后要执行的函数。而第三个参数默认值是false，表示在事件冒泡的阶段调用事件处理函数，如果参数为true，则表示在事件捕获阶段调用处理函数 DOM 事件流 事件捕获阶段 处于目标阶段 事件冒泡阶段 阻止事件冒泡 1event.stopPropagation()","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"Dom","slug":"Dom","permalink":"http://yoursite.com/tags/Dom/"}]},{"title":"如何配置github ssh连接","slug":"github-ssh-config","date":"2017-01-19T08:24:06.000Z","updated":"2017-01-19T08:28:43.629Z","comments":true,"path":"2017/01/19/github-ssh-config/","link":"","permalink":"http://yoursite.com/2017/01/19/github-ssh-config/","excerpt":"","text":"测试ssh连接是否正常1ssh -T git@coding.net 配置ssh连接1. 打开gitbash2. 生成public key用以下命令 邮箱换成自己的 1ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" 一路回车就行了 3. 找到生成的public key添加到github首先找到公钥文件id_rsa.pub，默认目录为C:/Users/[username]/.ssh，用文本编辑器打开并复制 然后参考这里 到这里就ok了可以找repo pull/push一下试一试了","categories":[],"tags":[]},{"title":"html input","slug":"html-input","date":"2017-01-19T08:12:32.000Z","updated":"2017-01-19T08:29:30.297Z","comments":true,"path":"2017/01/19/html-input/","link":"","permalink":"http://yoursite.com/2017/01/19/html-input/","excerpt":"","text":"在html5中 对于 1&lt;input type=\"file\"&gt; 可以用accept属性指定接收的文件类型。 Snytax1&lt;input accept=\"file_extension|audio/*|video/*|image/*|media_type\"&gt; To specify more than one value, separate the values with a comma (e.g. 1&lt;input accept=\"audio/*,video/*,image/*\" /&gt;","categories":[],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"Vue.js学习 - 创建第一个应用","slug":"vuejs-1","date":"2016-12-13T07:34:39.000Z","updated":"2016-12-13T13:05:40.340Z","comments":true,"path":"2016/12/13/vuejs-1/","link":"","permalink":"http://yoursite.com/2016/12/13/vuejs-1/","excerpt":"","text":"在github上创建一个项目在本地创建对应的reproinit git123456echo \"# test\" &gt;&gt; README.mdgit initgit add README.mdgit commit -m \"first commit\"git remote add origin https://github.com/BigYu/test.gitgit push -u origin master 我创建了两个branch，master和develop。如果是一个人写的小项目，其实没有必要。管他呢，就当假装follow gitflow的一点执念吧，嘻嘻。 init npm 加上-y选项，即全部填写默认值。如果将来需要修改，在文件里修改吧，什么都没写的时候干这些意义不大 准备好第三方依赖梳理一下我要用啥 vue.js ES2015(6?) &amp; babel webpack/webpack devserver sass 先暂时想到这些。以后想起来再加。 安装webpack12npm install --save-dev webpacknpm install webpack-dev-server -g dev server用于本地调试，所以没有加入到packages.json里 使用webpack dev server webpack.config.js 12345678910module.exports = &#123; entry: './src/index.js', output: &#123; path: './assets', filename: 'bundle.js' &#125;, devServer: &#123; port: 99 &#125;&#125;; src/index.js 1document.write('Hello vue!!! I am Yucong.'); bash commands 1webpack dev server 浏览器打开 http://localhost:99/webpack-dev-server/bundle 就能看到啦。自动刷新哦~ webpack bash command 1webpack 然后就看到bundle.js在assets目录下被创建了 再加入一个index.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=\"assets/bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 安装babel loader并调试 install 1npm install babel-loader babel-core babel-preset-es2015 --save-dev config 123456789101112module: &#123; loaders: [ &#123; test: /\\.js$/, exclude: /(node_modules|bower_components)/, loader: 'babel-loader', query: &#123; presets: ['es2015'] &#125; &#125; ]&#125; src/index.js 123import './test1';document.write('Hello vue!!! I am Yucong.'); src/test1.js 123import './test_module/test2';window.console.log('Hello'); src/test_module/test2.js 123456import test3 from './test3';const a = 2;alert(a);alert(test3.foo); src/test_module/test3.js 123export default &#123; foo: 'bar',&#125;; 这里还有一个问题，所有的import path都是相对路径，还不知道怎么做成绝对路径。。。 html loader1npm install html-loader --save-dev config 12 安装vue.js 写一个hello word1npm install vue --save index.js 12345678import Vue from 'vue';new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!', &#125;&#125;); The runtime-only build does not include the template compiler, and does not support the template option. You can only use the render option when using the runtime-only build, but it works with single-file components, because single-file components’ templates are pre-compiled into render functions during the build step. The runtime-only build is roughly 30% lighter-weight than the standalone build, weighing only 17.60kb min+gzip. 12345resolve: &#123; alias: &#123; 'vue$': 'vue/dist/vue.common.js' &#125;&#125; index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; &lt;script src=\"/bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"Frameworks","slug":"Frameworks","permalink":"http://yoursite.com/tags/Frameworks/"},{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/tags/Vue-js/"}]},{"title":"underscore源码阅读笔记（5）： defer","slug":"underscore-5","date":"2016-12-03T06:03:34.000Z","updated":"2016-12-03T06:37:09.894Z","comments":true,"path":"2016/12/03/underscore-5/","link":"","permalink":"http://yoursite.com/2016/12/03/underscore-5/","excerpt":"","text":"这周被邪恶的knockout狠狠的坑了一次，解决方法是用defer函数让ko的binding让调用栈结束之后进行。于是看了一下源码，了解一下defer的实现。 defer1_.defer = _.partial(_.delay, _, 1); partial123456789101112131415// Partially apply a function by creating a version that has had some of its// arguments pre-filled, without changing its dynamic `this` context. _ acts// as a placeholder, allowing any combination of arguments to be pre-filled._.partial = function(func) &#123; var boundArgs = slice.call(arguments, 1); var bound = function() &#123; var position = 0, length = boundArgs.length; var args = Array(length); for (var i = 0; i &lt; length; i++) &#123; args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i]; &#125; while (position &lt; arguments.length) args.push(arguments[position++]); return executeBound(func, bound, this, this, args); &#125;; return Partially apply a function by filling in any number of its arguments, without changing its dynamic this value. A close cousin of bind. You may pass _ in your list of arguments to specify an argument that should not be pre-filled, but left open to supply at call-time. 123456789var subtract = function(a, b) &#123; return b - a; &#125;;sub5 = _.partial(subtract, 5);sub5(20);=&gt; 15// Using a placeholdersubFrom20 = _.partial(subtract, _, 20);subFrom20(5);=&gt; 15 delay12345678// Delays a function for the given number of milliseconds, and then calls// it with the arguments supplied._.delay = function(func, wait) &#123; var args = slice.call(arguments, 2); return setTimeout(function()&#123; return func.apply(null, args); &#125;, wait);&#125;; setTimeout() will run asynchronously after finishing current execution block.","categories":[],"tags":[]},{"title":"Airbnb JavaScript Style Guide","slug":"code-convention","date":"2016-10-13T01:25:20.000Z","updated":"2016-10-17T07:53:31.754Z","comments":true,"path":"2016/10/13/code-convention/","link":"","permalink":"http://yoursite.com/2016/10/13/code-convention/","excerpt":"","text":"Note that both let and const are block-scoped. 1234567// const and let only exist in the blocks they are defined in.&#123; let a = 1; const b = 1;&#125;console.log(a); // ReferenceErrorconsole.log(b); // ReferenceError Use computed property names when creating objects with dynamic property names. 1234567891011121314151617function getKey(k) &#123; return `a key named $&#123;k&#125;`;&#125;// badconst obj = &#123; id: 5, name: 'San Francisco',&#125;;obj[getKey('enabled')] = true;// goodconst obj = &#123; id: 5, name: 'San Francisco', [getKey('enabled')]: true,&#125;; Do not call Object.prototype methods directly, such as hasOwnProperty, propertyIsEnumerable, and isPrototypeOf. Why? These methods may be shadowed by properties on the object in question - consider { hasOwnProperty: false } - or, the object may be a null object (Object.create(null)). 123456789101112// badconsole.log(object.hasOwnProperty(key));// goodconsole.log(Object.prototype.hasOwnProperty.call(object, key));// bestconst has = Object.prototype.hasOwnProperty; // cache the lookup once, in module scope./* or */const has = require('has');…console.log(has.call(object, key)); Use array spreads … to copy arrays. 1234567891011// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; Use object destructuring when accessing and using multiple properties of an object. jscs: Why? Destructuring saves you from creating temporary references for those properties. 123456789101112131415161718// badfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;// goodfunction getFullName(user) &#123; const &#123; firstName, lastName &#125; = user; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125; Use array destructuring. jscs: requireArrayDestructuring 12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; Strings that cause the line to go over 100 characters should not be written across multiple lines using string concatenation. 12345678910111213// badconst errorMessage = 'This is a super long error that was thrown because \\of Batman. When you stop to think about how Batman had anything to do \\with this, you would get nowhere \\fast.';// badconst errorMessage = 'This is a super long error that was thrown because ' + 'of Batman. When you stop to think about how Batman had anything to do ' + 'with this, you would get nowhere fast.';// goodconst errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.'; Do not unnecessarily escape characters in strings. eslint: no-useless-escape 123456// badconst foo = '\\'this\\' \\i\\s \\\"quoted\\\"';// goodconst foo = '\\'this\\' is \"quoted\"';const foo = `'this' is \"quoted\"`; Use named function expressions instead of function declarations. eslint: func-style jscs: 1234567891011// badconst foo = function () &#123;&#125;;// badfunction foo() &#123;&#125;// goodconst foo = function bar() &#123;&#125;; Prefer the use of the spread operator … to call variadic functions. eslint: prefer-spread 12345678910111213// badconst x = [1, 2, 3, 4, 5];console.log.apply(console, x);// goodconst x = [1, 2, 3, 4, 5];console.log(...x);// badnew (Function.prototype.bind.apply(Date, [null, 2016, 08, 05]));// goodnew Date(...[2016, 08, 05]);","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"有位孤独的裱糊匠","slug":"essay0","date":"2016-09-18T01:17:38.000Z","updated":"2016-09-26T01:22:17.741Z","comments":true,"path":"2016/09/18/essay0/","link":"","permalink":"http://yoursite.com/2016/09/18/essay0/","excerpt":"","text":"说起爱国，每个人都曾经在昏黄的灯光下，啃那些令人热血沸腾的一行行，一段段。也想过能振臂一呼“为中华之崛起而读书”。然而一百年过去了，我泱泱中华也早已不再是那个任人鱼肉的东亚病夫之邦，莘莘学子也早无救亡图存之忧，偶有几个不知是不是无病呻吟之辈锤着打鼓摇着“爱国主义教育”的旌旗，不得回应而啐骂小生们欺师忘祖谓之“毁掉的一代”。或者更需要的是在静夜的微风中细细琢磨一下，究竟何谓爱国，何谓国士，何谓英雄，那些年这块染血的土地上究竟是哪些人在扛着破败飘摇的民族前进。翁同龢之辈？他对中华的祸害，怕是远甚于巨贪和珅和清末一干赃官污吏。甲午年鲜血染红的黄海上，多少将士恨不能食其肉寝其皮，此之谓爱国贼。然而他忠心耿耿，满腹经纶，书法文章无不精通，若不是拖甲午战争后腿这个地实在不好洗，有人还想着树之为书生榜样让天下学子效仿吧。邓世昌邓公，此日漫挥天下泪，有公足壮海军威，岂不是大英雄。且不论多少凡夫俗子有邓公之志，邓公之才，邓公之威，只是不知道那些挥着热血红旗的人，可曾计算过要用多少大英雄的躯体，用多少致远舰的残骸，去填平专制农业国和宪政工业国之间的沟壑？哦，对了，百年来，举国歌颂纪念邓公，唯有一大汉奸卖国贼不以为然，认为此举不值得提倡，命令众官兵不要效仿。还修定了《海军惩劝章程》，担心将士们都学邓世昌，以轻生为壮。这个人把自己的姓名，签在了丧权辱国的马关条约和辛丑条约上。这个人不顾我中华上下五千年之文明，整天洋人长洋人短的鼓吹西洋奇技淫巧。这个人无视我中华地大物博，四万万众志成城的百姓，百万正义之师，却宣扬东洋的蕞尔小国多么强大，八国混杂的乌合之众装备精良，闭港闭关不敢一战。 一百年前的一个傍晚，地平线上矮矮的挂着帝国昏黄夕阳，狼狈的老佛爷光绪帝在西边餐风饮露惶惶如丧家之犬，豺狗般的八国联军在京师烧杀掳掠把东方的瑰宝装上强盗的货轮。还有那位孤独的老人领了老佛爷的懿旨正前往那龙潭虎穴之地。他在想什么？那部已经“不再公开播出”的电视剧中给出了这样一个有趣的场景：老者重重的拿皮鞭抽着陀螺，脸上孩童般的笑容，对着身边的丫鬟笑道：“又要去卖国，当汉奸，去卖国，去当汉奸，去卖国，去当汉奸。。。”或者谈判桌上，换上哪位爱国志士，直斥八国军匪虎狼之心，豺狼之态，让他们知道我们威武天朝正义之师不可战胜，就能让他们俯首称臣，省下那九万万两白银。又或者哪位大儒圣贤，能开化与鸟兽为伍的洋鬼子，使之知礼孝廉耻，明仁义道德，读四书五经，然后知道自己所作所为大悖伦常之道，能在孔孟圣贤庙前向我们赔礼道歉，然后受我天子教化。 签字的是不是李中堂，除了决定历史课本上黑锅的归属，怕是改变不了中华被列强蹂躏的命运；但从帝国主义嘴里抠回来辽东半岛，抠回来被彻底肢解的命运，恐怕那段岁月里在朝廷上粉墨登场过的，能做到的，也只有一个李鸿章吧。其实他应该蠢一点，无能一点，愚昧一点，或者能让已经瓤子里腐败的清廷，支离破碎的更早一点吧。哦，对了，少荃在日本，还吃了一颗价值一亿两白银的子弹呢。不知道现在的日本国民，是如何看待他们那位开枪的爱国青年的。哦，对了，就算历史课本上给黄海海战的结论是“北洋水师全军覆没”，别忘了日本人可打不沉定远镇远二舰。直到二战，这铁甲巨舰的路线还在发挥着威力。甚至几十年后二战太平洋和大西洋血染的海面上，还在证明着李中堂思路的正确。 “这是一个人对一个国家的战争”这是国外对甲午战争的一句评论。我们很难判断这句话是否成立——更可能的，这并非一个可以判断真伪的命题，儿仅仅是看到一个拥有“五千年文明”，“地大物博”，“不必与西洋互通有无”的大国支离破碎之后的一句感慨。历史的车轮在时光轴的这个横断面，刻下了一个大大的感叹号！四万万人中，难道只有这么一位可以大声疾呼“世界正经历三千年未有之巨变”，只有以变求变，才能有一线生机。至于那些跪倒在“祖宗之法”“圣贤教诲”前面泣血上奏的忠臣们，他们对中华的祸害，远甚于贪官污吏，远甚于流氓盗匪！时至今日，大家无不感叹鸿章大人生不逢时。但细细一想，也许所有真正能牵引时代前进的人，都要被打上一个“生不逢时”的标签吧：很难被他周围的人认可，不像李某落得个遗臭万年的下场，就算不错了。——这种人是为了未来制造的，为了那个还没有被世人，没有被当时掌握话语权的“主流”接受的那个未来。 所以，我们的历史书上，歌颂的是邓世昌。总不能歌颂翁老吧。他属于那个忠君报国的现在，属于那个清正廉明的现在。而李鸿章，属于那个机械轰鸣的未来。还有，那个帝国落日余晖折射下，民族无奈的未来。还有，他不停的要银子，花在破坏风水的洋务上，花在千里之外的海上。让京城里老佛爷的六十大寿，过得不那么开心啊。这岂是能鼓励和颂扬的？ 我们还是不要把历史当笑话读吧，也许今晚睡前可以话十分钟闭目想一下，我们每天茫茫碌碌，究竟是在修建那座美轮美奂的颐和园，还是打造一支也许回沉没的北洋水师。我们究竟在为老佛爷的六十大寿奋斗，还有没有隐隐为“未来”的波涛汹涌担忧。李鸿章是悲剧。让李鸿章出现的时代也是悲剧。土地上的亭台阁楼建起来了，时代的大屋子，去只能靠这位苍老的裱糊匠孤独的修补。那个风雨飘摇中踽踽独行的背影，是不是不应该那么熟悉？","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"underscore源码阅读笔记（4）： eq(cont.)","slug":"underscore-4","date":"2016-09-07T03:01:11.000Z","updated":"2016-09-07T03:18:06.358Z","comments":true,"path":"2016/09/07/underscore-4/","link":"","permalink":"http://yoursite.com/2016/09/07/underscore-4/","excerpt":"","text":"javascript判断变量类型的方法 javascript中 一切皆对象 1234567console.log(toString.call([123]));//[object Array]console.log(toString.call('123'));//[object String]console.log(toString.call(&#123;a: '123'&#125;));//[object Object]console.log(toString.call(/123/));//[object RegExp]console.log(toString.call(123));//[object Number]console.log(toString.call(undefined));//[object Undefined]console.log(toString.call(null));//[object Null] eq函数中不同类型的“相等”判断RegExp和string12345678// Strings, numbers, regular expressions, dates, and booleans are compared by value.case '[object RegExp]':// RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')case '[object String]': // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is // equivalent to `new String(\"5\")`. return '' + a === '' + b;· 以下“相等”均表示eq返回true 一个正则表达式 加上’’ 仍让与原来相等 “abc”和new String(‘abc’)是相等的 Number·123456case '[object Number]': // `NaN`s are equivalent, but non-reflexive. // Object(NaN) is equivalent to NaN if (+a !== +a) return +b !== +b; // An `egal` comparison is performed for other numeric values. return +a === 0 ? 1 / +a === 1 / b : +a === +b; js中 +NaN === +NaN 为false Object(NaN)和NaN相等 Date/Boolean123456case &apos;[object Date]&apos;:case &apos;[object Boolean]&apos;: // Coerce dates and booleans to numeric primitive values. Dates are compared by their // millisecond representations. Note that invalid dates with millisecond representations // of `NaN` are not equivalent. return +a === +b; To be continued","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"css中的定位","slug":"css-position","date":"2016-09-02T12:30:06.000Z","updated":"2016-09-26T01:22:12.914Z","comments":true,"path":"2016/09/02/css-position/","link":"","permalink":"http://yoursite.com/2016/09/02/css-position/","excerpt":"","text":"css的position属性定义元素的定位类型，Position属性有四个值：static、fixed、absolute和relative。主流的浏览器都是支持所有值的。 著名坑爹货：任何的版本的 Internet Explorer （包括 IE8）都不支持属性值 “inherit”。 static默认值 表示一个元素不会被positioned 仍然放在正常文档流中（“正常”是什么东西见上一篇关于浮动的） relative基本的表现和static一样 不同的是可以用top bottom left right属性来控制元素位置的偏移 fixed相对于视窗定位 就是说 即使页面滚动 元素的位置仍然不会改变 absuloteabsolute 与 fixed 的表现类似，除了它不是相对于视窗而是相对于最近的“positioned”祖先元素。如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它是相对于文档的 body 元素，并且它会随着页面滚动而移动。 一个“positioned”元素是指position 值不是 static 的元素。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"underscore源码阅读笔记（3）： eq","slug":"underscore-3","date":"2016-08-22T06:16:09.000Z","updated":"2016-08-22T06:16:15.202Z","comments":true,"path":"2016/08/22/underscore-3/","link":"","permalink":"http://yoursite.com/2016/08/22/underscore-3/","excerpt":"","text":"eq 函数源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// Internal recursive comparison function for `isEqual`.var eq = function(a, b, aStack, bStack) &#123; // Identical objects are equal. `0 === -0`, but they aren't identical. // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal). if (a === b) return a !== 0 || 1 / a === 1 / b; // A strict comparison is necessary because `null == undefined`. if (a == null || b == null) return a === b; // Unwrap any wrapped objects. if (a instanceof _) a = a._wrapped; if (b instanceof _) b = b._wrapped; // Compare `[[Class]]` names. var className = toString.call(a); if (className !== toString.call(b)) return false; switch (className) &#123; // Strings, numbers, regular expressions, dates, and booleans are compared by value. case '[object RegExp]': // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i') case '[object String]': // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is // equivalent to `new String(\"5\")`. return '' + a === '' + b; case '[object Number]': // `NaN`s are equivalent, but non-reflexive. // Object(NaN) is equivalent to NaN if (+a !== +a) return +b !== +b; // An `egal` comparison is performed for other numeric values. return +a === 0 ? 1 / +a === 1 / b : +a === +b; case '[object Date]': case '[object Boolean]': // Coerce dates and booleans to numeric primitive values. Dates are compared by their // millisecond representations. Note that invalid dates with millisecond representations // of `NaN` are not equivalent. return +a === +b; &#125; var areArrays = className === '[object Array]'; if (!areArrays) &#123; if (typeof a != 'object' || typeof b != 'object') return false; // Objects with different constructors are not equivalent, but `Object`s or `Array`s // from different frames are. var aCtor = a.constructor, bCtor = b.constructor; if (aCtor !== bCtor &amp;&amp; !(_.isFunction(aCtor) &amp;&amp; aCtor instanceof aCtor &amp;&amp; _.isFunction(bCtor) &amp;&amp; bCtor instanceof bCtor) &amp;&amp; ('constructor' in a &amp;&amp; 'constructor' in b)) &#123; return false; &#125; &#125; // Assume equality for cyclic structures. The algorithm for detecting cyclic // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`. // Initializing stack of traversed objects. // It's done here since we only need them for objects and arrays comparison. aStack = aStack || []; bStack = bStack || []; var length = aStack.length; while (length--) &#123; // Linear search. Performance is inversely proportional to the number of // unique nested structures. if (aStack[length] === a) return bStack[length] === b; &#125; // Add the first object to the stack of traversed objects. aStack.push(a); bStack.push(b); // Recursively compare objects and arrays. if (areArrays) &#123; // Compare array lengths to determine if a deep comparison is necessary. length = a.length; if (length !== b.length) return false; // Deep compare the contents, ignoring non-numeric properties. while (length--) &#123; if (!eq(a[length], b[length], aStack, bStack)) return false; &#125; &#125; else &#123; // Deep compare objects. var keys = _.keys(a), key; length = keys.length; // Ensure that both objects contain the same number of properties before comparing deep equality. if (_.keys(b).length !== length) return false; while (length--) &#123; // Deep compare each member key = keys[length]; if (!(_.has(b, key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) return false; &#125; &#125; // Remove the first object from the stack of traversed objects. aStack.pop(); bStack.pop(); return true;&#125;; 1234// Perform a deep comparison to check if two objects are equal._.isEqual = function(a, b) &#123; return eq(a, b);&#125;; 0 和 -0 的不同判断 123// Identical objects are equal. `0 === -0`, but they aren't identical.// See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).if (a === b) return a !== 0 || 1 / a === 1 / b; 在这里判断时，因为1/0会得到Infinite，而1/-0会得到-Infinite,而 Infinite === - Infinite会得到false，所以_.isEqual(0, -0)会得到false，尽管0 === -0会得到true。更加详细的说明作者在comments中提供了有详细解释的链接。 _.isEqual(null, undefined) 会得到false 12// A strict comparison is necessary because `null == undefined`.if (a == null || b == null) return a === b; 开始根据Classname来进行深度比较 123// Compare `[[Class]]` names.var className = toString.call(a);if (className !== toString.call(b)) return false; 这里会有一个很自然的疑问：下面那一行if是用来干嘛的？上面刚刚赋值，难道这里还会有以外吗？会！ 1[] !== [] // it is true! 之后就会根据不同的class（或者说type吧）进行不同的比较 未完待续","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"css中著名的坑爹货：浮动(float)和清浮动(clear)","slug":"css-float","date":"2016-08-18T11:29:59.000Z","updated":"2016-08-18T12:48:05.866Z","comments":true,"path":"2016/08/18/css-float/","link":"","permalink":"http://yoursite.com/2016/08/18/css-float/","excerpt":"","text":"css正常流布局div是html中最常见的元素，也是最典型的块级元素。块级元素会按照html中的顺序从上到下依次布局，每个占一行，也就是我们所说的“流”例子 而其他所有神奇的布局，归根结底都是解决一个问题： 如何在一行显示多个元素。 浮动浮动可以理解为（非准确定义！）：让块级元素脱离标准流，漂浮在另一个层次上 比如说上面的例子 我们让b浮动:b float left结果是，表示c的蓝色元素被挡住看不见了。因为b在浮动，不参与标准流布局，a,c,d仍然按照标准流布局，“漂浮”着的b挡住了c。并且这里的b是靠左排列，因为是左浮动，右浮动就是靠右排列：b float right让b和c一起左浮动 a和d会组成新的标准流， c会跟在b的后面，如果一行排不下，会被挤到下一行 ， d仍然在正常流中，被挡住。多个浮动元素的情况可以以此类推，就是一个跟着一个往一排里放，放不下了就放下一排。从左从右由浮动种类决定。这里可以出题啦：瀑布流，哇咔咔。这个写完了基本上面的就木有问题了。这里给个参考：https://github.com/duitang/waterfall 浮动元素和非浮动元素的排列 划重点啦 划重点啦 上面的b都是浮动的，a都是正常的。然后b都是在a的下面！！！重点，手动红色下划线： 假如某个div元素A是浮动的，如果A元素上一个元素也是浮动的，那么A元素会跟随在上一个元素的后边(如果一行放不下这两个元素，那么A元素会被挤到下一行)；如果A元素上一个元素是标准流中的元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐。 inline元素和浮动CSS display是指显示状态，inline表示内联，特点是紧贴着前一个内联元素，通常默认的内联元素有span,a,em,strong等。任何不是块级元素的可见元素都是内联元素.他和浮动的区别在于: inline元素是不能设置宽和高的。 打屁股的作业如下： 1&lt;span class=\"foo\"&gt;&lt;/span&gt;span&gt; 1234.foo &#123; width: 100px; height: 100px;&#125; 清浮动 语法： clear : none | left | right | both 取值： none : 默认值。允许两边都可以有浮动对象 left : 不允许左边有浮动对象 right : 不允许右边有浮动对象 both : 不允许有浮动对象 不清浮动清除d的左浮动 Bootstrap中的浮动向左快速浮动：pull-left向右快速浮动：pull-right清除浮动：clearfix","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"underscore源码阅读笔记（2）： reduce","slug":"underscore-2","date":"2016-08-17T02:01:07.000Z","updated":"2016-08-17T02:19:24.959Z","comments":true,"path":"2016/08/17/underscore-2/","link":"","permalink":"http://yoursite.com/2016/08/17/underscore-2/","excerpt":"","text":"reduce和reduceRight的实现： 123456// **Reduce** builds up a single result from a list of values, aka `inject`,// or `foldl`._.reduce = _.foldl = _.inject = createReduce(1);// The right-associative version of reduce, also known as `foldr`._.reduceRight = _.foldr = createReduce(-1); 核心：createReduce - 这是一个function decorator: 12345678910111213141516171819202122232425// Create a reducing function iterating left or right.function createReduce(dir) &#123; // Optimized iterator function as using arguments.length // in the main function will deoptimize the, see #1991. function iterator(obj, iteratee, memo, keys, index, length) &#123; for (; index &gt;= 0 &amp;&amp; index &lt; length; index += dir) &#123; var currentKey = keys ? keys[index] : index; memo = iteratee(memo, obj[currentKey], currentKey, obj); &#125; return memo; &#125; return function(obj, iteratee, memo, context) &#123; iteratee = optimizeCb(iteratee, context, 4); var keys = !isArrayLike(obj) &amp;&amp; _.keys(obj), length = (keys || obj).length, index = dir &gt; 0 ? 0 : length - 1; // Determine the initial value if none is provided. if (arguments.length &lt; 3) &#123; memo = obj[keys ? keys[index] : index]; index += dir; &#125; return iterator(obj, iteratee, memo, keys, index, length); &#125;;&#125; Optimized iterator function as using arguments.length in the main function will deoptimize the, see #1991. 换我这种人来写，肯定就是用arguments.length来取一下，然后开开心心的开始for循环了，嘿嘿嘿 195行到198行在干嘛？如果没有传初始值，则把第一个值作为初始值，同时移动一下初始迭代位置 191行同时支持数组和集合。可以借鉴：）","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"underscore源码阅读笔记（1）： optimizeCb","slug":"underscore-1","date":"2016-08-16T06:33:40.000Z","updated":"2016-08-16T07:04:06.316Z","comments":true,"path":"2016/08/16/underscore-1/","link":"","permalink":"http://yoursite.com/2016/08/16/underscore-1/","excerpt":"","text":"1234567891011121314151617181920212223// Internal function that returns an efficient (for current engines) version// of the passed-in callback, to be repeatedly applied in other Underscore// functions.var optimizeCb = function(func, context, argCount) &#123; if (context === void 0) return func; switch (argCount == null ? 3 : argCount) &#123; case 1: return function(value) &#123; return func.call(context, value); &#125;; case 2: return function(value, other) &#123; return func.call(context, value, other); &#125;; case 3: return function(value, index, collection) &#123; return func.call(context, value, index, collection); &#125;; case 4: return function(accumulator, value, index, collection) &#123; return func.call(context, accumulator, value, index, collection); &#125;; &#125; return function() &#123; return func.apply(context, arguments); &#125;;&#125;; 这里主要做了两个地方的优化可以注意： 避免使用arguments，尽量使用指定参数 尽量用call而不是apply","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"jquery 为动态添加的元素绑定事件","slug":"jQuery-Delegate-events","date":"2016-08-01T07:45:46.000Z","updated":"2016-08-01T07:46:52.433Z","comments":true,"path":"2016/08/01/jQuery-Delegate-events/","link":"","permalink":"http://yoursite.com/2016/08/01/jQuery-Delegate-events/","excerpt":"","text":"live函数已经被废弃了！！ 如果直接写click函数的话，只能把事件绑定在已经存在的元素上，不能绑定在动态添加的元素上 尝试过重新调用，结果是重复触发。。。 ###可以用delegate来实现 1.delegate( selector, eventType, handler ) 例如： 1234$('someUlSelector').delegate('someLiSelector', 'click', function() &#123; //codes... //$(this) for the current jquery instance of the element&#125;);","categories":[],"tags":[{"name":"Frameworks","slug":"Frameworks","permalink":"http://yoursite.com/tags/Frameworks/"}]},{"title":"What I learn after first glance on ReactJs","slug":"React-notes","date":"2016-08-01T04:47:47.000Z","updated":"2016-08-01T05:40:10.891Z","comments":true,"path":"2016/08/01/React-notes/","link":"","permalink":"http://yoursite.com/2016/08/01/React-notes/","excerpt":"","text":"就不再这里罗列各种关于React的新特性或者feature了，意义不大，而且我也是初学者。之前我个人也一直很喜欢Facebook的东西——小巧，简单，清晰，还有他们漂亮的文档实在是吸引人去看。 f(Status) = UI 这个公式可以概括React作为view层面的framework最精髓的地方。你的code可以根据逻辑操作status。status的变化反映在UI上的变化大部分工作室React帮我们做的，开发者只需要很少的精力去编写，或者说是配置status和UI之间的映射关系。UI是复杂的，我们现在处理五花八门的dom结构就已经十分头痛了，再加上种类越来越多的富文本元素，再加上，再加上越来越复杂的动态交互，使得现在UI的开发成本越来越高，代码越来越复杂，而且runtime的维护成本也越来越高。包括缓存在内的问题也越来越棘手。Status是简单的，清晰的（我觉得清晰比简单更加能吸引我。当然，让事情变简单可以让事情变清晰）。Status就是数据结构，对于UI来说，并不会十分复杂和庞大，一般只需要一些简单的array和object。处理他们是程序员们最熟悉的事情，而且可以想象代码可以像数据结构课本上那么清晰明了。另外，做UI的Cache和Delta的代价显然十分高昂，但是换成这么一堆初学者都能看懂的array啊object啊就完全不是问题了，这也是React给出来的魔术般的解决缓存和Performance的策略：页面的render是基于status update的delta来的。 单向数据流 我们之前遇到的各种前端框架显然不满足 1f(Status) = UI 通常来说，应该是 1f(Status, 用户交互，推送信息，其他UI联动变化，……) = UI 那么React必然要做的事情就是实现一个 1g(上面其他因素) = status 这就是需要单向数据流的原因。我个人的体会，因为可能已经习惯了诸如knockout、angularjs等成熟的框架提供的各种完善的two-way data-binding的机制，第一眼很难接受React的one-way data flow，而且写一些很小的component的时候（比如hello world之类的），会发现很简单的事情反而需要我们花一些额外的精力。比如一个最简单的input框，如果用ko，只需要把他和vm上一个observable绑定就好了，在ng中也是很简单的ng-model=xxx，但是突然React告诉你，不行，你要绕一圈，你的输入只能作用于status的update，绕一圈才能回到UI的变化，当然不习惯。Facebook的工程师们肯定不是吃饱了撑的才这样设计。我们可以想象一些稍微复杂的逻辑——比如，如果这个input框需要把用户的输入全部转成大写字母，或者拒绝掉一些非法字符。当然，现在的框架已经足够优秀，我们可以pass in各种custom filter。问题就在于当这些需求一个一个堆砌起来，逻辑就会逐渐变得混乱，filter，suscription，events等等聚集在一起，代码的可读性会严重降低且难以维护。当UI中的元素越来越多，业务越来越复杂，这些不便利之处会指数级爆炸。而单向的数据流就不存在这些问题了，flux中有一个很好的Dispature和Store的概念，就像现代物流的集散分拣中心一样的（此处谢绝抬杠），一件快递的时候看起来不必要，但是成千上万的数据涌来，他依然能把所有的东西处理得井井有条，所有的东西就像阅兵式上的方阵，清晰有条理。我们会被从filter，suscription，events中被拯救出来，只有两样简单的事情：status，UI。","categories":[],"tags":[{"name":"Frameworks","slug":"Frameworks","permalink":"http://yoursite.com/tags/Frameworks/"}],"keywords":["React Js","One-way data-binding","UI"]},{"title":"Hello World","slug":"hello-world","date":"2016-07-31T10:19:21.655Z","updated":"2016-07-31T10:19:21.662Z","comments":true,"path":"2016/07/31/hello-world/","link":"","permalink":"http://yoursite.com/2016/07/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}