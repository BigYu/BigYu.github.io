{"meta":{"title":"Yucong's Blog","subtitle":null,"description":"No matter where we are going, it starts from where we are","author":"体力劳动者","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"css中著名的坑爹货：浮动(float)和清浮动(clear)","slug":"css-float","date":"2016-08-18T11:29:59.000Z","updated":"2016-08-18T12:48:05.866Z","comments":true,"path":"2016/08/18/css-float/","link":"","permalink":"http://yoursite.com/2016/08/18/css-float/","excerpt":"","text":"css正常流布局div是html中最常见的元素，也是最典型的块级元素。块级元素会按照html中的顺序从上到下依次布局，每个占一行，也就是我们所说的“流”例子 而其他所有神奇的布局，归根结底都是解决一个问题： 如何在一行显示多个元素。 浮动浮动可以理解为（非准确定义！）：让块级元素脱离标准流，漂浮在另一个层次上 比如说上面的例子 我们让b浮动:b float left结果是，表示c的蓝色元素被挡住看不见了。因为b在浮动，不参与标准流布局，a,c,d仍然按照标准流布局，“漂浮”着的b挡住了c。并且这里的b是靠左排列，因为是左浮动，右浮动就是靠右排列：b float right让b和c一起左浮动 a和d会组成新的标准流， c会跟在b的后面，如果一行排不下，会被挤到下一行 ， d仍然在正常流中，被挡住。多个浮动元素的情况可以以此类推，就是一个跟着一个往一排里放，放不下了就放下一排。从左从右由浮动种类决定。这里可以出题啦：瀑布流，哇咔咔。这个写完了基本上面的就木有问题了。这里给个参考：https://github.com/duitang/waterfall 浮动元素和非浮动元素的排列 划重点啦 划重点啦 上面的b都是浮动的，a都是正常的。然后b都是在a的下面！！！重点，手动红色下划线： 假如某个div元素A是浮动的，如果A元素上一个元素也是浮动的，那么A元素会跟随在上一个元素的后边(如果一行放不下这两个元素，那么A元素会被挤到下一行)；如果A元素上一个元素是标准流中的元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐。 inline元素和浮动CSS display是指显示状态，inline表示内联，特点是紧贴着前一个内联元素，通常默认的内联元素有span,a,em,strong等。任何不是块级元素的可见元素都是内联元素.他和浮动的区别在于: inline元素是不能设置宽和高的。 打屁股的作业如下： 1&lt;span class=\"foo\"&gt;&lt;/span&gt;span&gt; 1234.foo &#123; width: 100px; height: 100px;&#125; 清浮动 语法： clear : none | left | right | both 取值： none : 默认值。允许两边都可以有浮动对象 left : 不允许左边有浮动对象 right : 不允许右边有浮动对象 both : 不允许有浮动对象 不清浮动清除d的左浮动 Bootstrap中的浮动向左快速浮动：pull-left向右快速浮动：pull-right清除浮动：clearfix","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"underscore源码阅读笔记（2）： reduce","slug":"underscore-2","date":"2016-08-17T02:01:07.000Z","updated":"2016-08-17T02:19:24.959Z","comments":true,"path":"2016/08/17/underscore-2/","link":"","permalink":"http://yoursite.com/2016/08/17/underscore-2/","excerpt":"","text":"reduce和reduceRight的实现： 123456// **Reduce** builds up a single result from a list of values, aka `inject`,// or `foldl`._.reduce = _.foldl = _.inject = createReduce(1);// The right-associative version of reduce, also known as `foldr`._.reduceRight = _.foldr = createReduce(-1); 核心：createReduce - 这是一个function decorator: 12345678910111213141516171819202122232425// Create a reducing function iterating left or right.function createReduce(dir) &#123; // Optimized iterator function as using arguments.length // in the main function will deoptimize the, see #1991. function iterator(obj, iteratee, memo, keys, index, length) &#123; for (; index &gt;= 0 &amp;&amp; index &lt; length; index += dir) &#123; var currentKey = keys ? keys[index] : index; memo = iteratee(memo, obj[currentKey], currentKey, obj); &#125; return memo; &#125; return function(obj, iteratee, memo, context) &#123; iteratee = optimizeCb(iteratee, context, 4); var keys = !isArrayLike(obj) &amp;&amp; _.keys(obj), length = (keys || obj).length, index = dir &gt; 0 ? 0 : length - 1; // Determine the initial value if none is provided. if (arguments.length &lt; 3) &#123; memo = obj[keys ? keys[index] : index]; index += dir; &#125; return iterator(obj, iteratee, memo, keys, index, length); &#125;;&#125; Optimized iterator function as using arguments.length in the main function will deoptimize the, see #1991. 换我这种人来写，肯定就是用arguments.length来取一下，然后开开心心的开始for循环了，嘿嘿嘿 195行到198行在干嘛？如果没有传初始值，则把第一个值作为初始值，同时移动一下初始迭代位置 191行同时支持数组和集合。可以借鉴：）","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"underscore源码阅读笔记（1）： optimizeCb","slug":"underscore-1","date":"2016-08-16T06:33:40.000Z","updated":"2016-08-16T07:04:06.316Z","comments":true,"path":"2016/08/16/underscore-1/","link":"","permalink":"http://yoursite.com/2016/08/16/underscore-1/","excerpt":"","text":"1234567891011121314151617181920212223// Internal function that returns an efficient (for current engines) version// of the passed-in callback, to be repeatedly applied in other Underscore// functions.var optimizeCb = function(func, context, argCount) &#123; if (context === void 0) return func; switch (argCount == null ? 3 : argCount) &#123; case 1: return function(value) &#123; return func.call(context, value); &#125;; case 2: return function(value, other) &#123; return func.call(context, value, other); &#125;; case 3: return function(value, index, collection) &#123; return func.call(context, value, index, collection); &#125;; case 4: return function(accumulator, value, index, collection) &#123; return func.call(context, accumulator, value, index, collection); &#125;; &#125; return function() &#123; return func.apply(context, arguments); &#125;;&#125;; 这里主要做了两个地方的优化可以注意： 避免使用arguments，尽量使用指定参数 尽量用call而不是apply","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"jquery 为动态添加的元素绑定事件","slug":"jQuery-Delegate-events","date":"2016-08-01T07:45:46.000Z","updated":"2016-08-01T07:46:52.433Z","comments":true,"path":"2016/08/01/jQuery-Delegate-events/","link":"","permalink":"http://yoursite.com/2016/08/01/jQuery-Delegate-events/","excerpt":"","text":"live函数已经被废弃了！！ 如果直接写click函数的话，只能把事件绑定在已经存在的元素上，不能绑定在动态添加的元素上 尝试过重新调用，结果是重复触发。。。 ###可以用delegate来实现 1.delegate( selector, eventType, handler ) 例如： 1234$('someUlSelector').delegate('someLiSelector', 'click', function() &#123; //codes... //$(this) for the current jquery instance of the element&#125;);","categories":[],"tags":[{"name":"Frameworks","slug":"Frameworks","permalink":"http://yoursite.com/tags/Frameworks/"}]},{"title":"What I learn after first glance on ReactJs","slug":"React-notes","date":"2016-08-01T04:47:47.000Z","updated":"2016-08-01T05:40:10.891Z","comments":true,"path":"2016/08/01/React-notes/","link":"","permalink":"http://yoursite.com/2016/08/01/React-notes/","excerpt":"","text":"就不再这里罗列各种关于React的新特性或者feature了，意义不大，而且我也是初学者。之前我个人也一直很喜欢Facebook的东西——小巧，简单，清晰，还有他们漂亮的文档实在是吸引人去看。 f(Status) = UI 这个公式可以概括React作为view层面的framework最精髓的地方。你的code可以根据逻辑操作status。status的变化反映在UI上的变化大部分工作室React帮我们做的，开发者只需要很少的精力去编写，或者说是配置status和UI之间的映射关系。UI是复杂的，我们现在处理五花八门的dom结构就已经十分头痛了，再加上种类越来越多的富文本元素，再加上，再加上越来越复杂的动态交互，使得现在UI的开发成本越来越高，代码越来越复杂，而且runtime的维护成本也越来越高。包括缓存在内的问题也越来越棘手。Status是简单的，清晰的（我觉得清晰比简单更加能吸引我。当然，让事情变简单可以让事情变清晰）。Status就是数据结构，对于UI来说，并不会十分复杂和庞大，一般只需要一些简单的array和object。处理他们是程序员们最熟悉的事情，而且可以想象代码可以像数据结构课本上那么清晰明了。另外，做UI的Cache和Delta的代价显然十分高昂，但是换成这么一堆初学者都能看懂的array啊object啊就完全不是问题了，这也是React给出来的魔术般的解决缓存和Performance的策略：页面的render是基于status update的delta来的。 单向数据流 我们之前遇到的各种前端框架显然不满足 1f(Status) = UI 通常来说，应该是 1f(Status, 用户交互，推送信息，其他UI联动变化，……) = UI 那么React必然要做的事情就是实现一个 1g(上面其他因素) = status 这就是需要单向数据流的原因。我个人的体会，因为可能已经习惯了诸如knockout、angularjs等成熟的框架提供的各种完善的two-way data-binding的机制，第一眼很难接受React的one-way data flow，而且写一些很小的component的时候（比如hello world之类的），会发现很简单的事情反而需要我们花一些额外的精力。比如一个最简单的input框，如果用ko，只需要把他和vm上一个observable绑定就好了，在ng中也是很简单的ng-model=xxx，但是突然React告诉你，不行，你要绕一圈，你的输入只能作用于status的update，绕一圈才能回到UI的变化，当然不习惯。Facebook的工程师们肯定不是吃饱了撑的才这样设计。我们可以想象一些稍微复杂的逻辑——比如，如果这个input框需要把用户的输入全部转成大写字母，或者拒绝掉一些非法字符。当然，现在的框架已经足够优秀，我们可以pass in各种custom filter。问题就在于当这些需求一个一个堆砌起来，逻辑就会逐渐变得混乱，filter，suscription，events等等聚集在一起，代码的可读性会严重降低且难以维护。当UI中的元素越来越多，业务越来越复杂，这些不便利之处会指数级爆炸。而单向的数据流就不存在这些问题了，flux中有一个很好的Dispature和Store的概念，就像现代物流的集散分拣中心一样的（此处谢绝抬杠），一件快递的时候看起来不必要，但是成千上万的数据涌来，他依然能把所有的东西处理得井井有条，所有的东西就像阅兵式上的方阵，清晰有条理。我们会被从filter，suscription，events中被拯救出来，只有两样简单的事情：status，UI。","categories":[],"tags":[{"name":"Frameworks","slug":"Frameworks","permalink":"http://yoursite.com/tags/Frameworks/"}],"keywords":["React Js","One-way data-binding","UI"]},{"title":"Hello World","slug":"hello-world","date":"2016-07-31T10:19:21.655Z","updated":"2016-07-31T10:19:21.662Z","comments":true,"path":"2016/07/31/hello-world/","link":"","permalink":"http://yoursite.com/2016/07/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}